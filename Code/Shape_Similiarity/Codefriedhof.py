# \label{py:Shape_Sim_Meas}
# 	Beide Versionen der YOLO Implementierung erzeugen ein mehrdimensionales Array, welches für jedes Frame jedes Polygon mit Gesamtwinkelsumme, Class ID und Umriss enthält. Dieses mehrdimensionale Array wird ausgewertet, um einzuschätzen, ob die DCE zum Objekttracking geeignet ist. 

# 	Die Ergebnisse werden in einem weiteren Dictionary gespeichert, welches als letzten Schritt in eine Textdatei geschrieben wird, um alle Ergebnisse und Einstellungen zentral zu speichern. In Listing \ref{cd:SSM_main.py} ist zu sehen, in welcher Reihenfolge die Analysemethoden aufgerufen werden. 
# 	\lstinputlisting[basicstyle=\ttfamily\scriptsize,linerange={4,11-17}, caption={Ausschnitt aus \protect\lstinline|calc_shape_similarity| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_main.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
# 	Nachdem die Zeitstempel berechnet und im Results Dictionary gespeichert wurden, wird die erste Analysemethode aufgerufen. Dies geschieht im Detail folgendermaßen.

# 	Die folgende Methode \lstinline|calc_shape_similarity_compare_polygons| vergleicht die Winkelsummen jedes einzelnen Polygon mit dem ähnlichen Polygon im nächsten Frame. Dies geschieht, indem bei der Detektion der Objekte nach dem Vereinfachen mit DCE ein mehrdimensionales Array mit den Daten [Framenummer, Polygonnummer, Gesamtwinkelsumme (im Polygon), ClassID, [Umrisskoordinaten]] angelegt wird, welches dann zu einem weiteren Array hinzugefügt wird. Dadurch ist jedes Polygon in jedem Frame einzeln identifzier- und vergleichbar. 
# 	Die Auswertung dieses mehrdimensionalen Arrays erfolgt ähnlich zu Listing \ref{cd:shape_sim_meas_compare_poly.py}.\\

# 	Die Schleife iteriert über alle Frames. Innerhalb dieser wird abgefragt, ob im nächsten Frame mehr Objekte detektiert wurden, als im betrachteten Frame. Dies ist wichtig, damit die nächste Schleife nur über so viele Polygone iteriert, wie das Frame mit der geringeren Anzahl hat. Wenn das nächste Frame jedoch weniger Polygone als das betrachtete Frame hat, dürfen nur so viele Polygone betrachtet werden, wie im nächsten Frame vorhanden sind. \\
# 	\lstinputlisting[basicstyle=\ttfamily\scriptsize,linerange={22,30,31,33-36,38-44}, caption={Ausschnitt 1 aus \protect\lstinline|calc_shape_similarity_compare_polygons| Funktion in sha\-pe\_sim\_me\-as.py}, label = {cd:shape_sim_meas_compare_poly.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
# 	Die integrierte FOR Schleife (siehe Listing \ref{cd:shape_sim_meas_compare_poly_second.py}) vergleicht die Winkelsummen der einzelnen Polygone. Dies wird dadurch ermöglicht, dass die temporäre Variable (\lstinline|temp|) nur dann berechnet wird, wenn das Polygon im betracheten Frame an der gleichen Stelle im Array steht, wie das Polygon im nächsten Frame. 
# 	\lstinputlisting[basicstyle=\ttfamily\scriptsize,firstnumber=15, linerange={45-51}, caption={Ausschnitt 2 aus \protect\lstinline|calc_shape_similarity_compare_polygons| Funktion in sha\-pe\_sim\_me\-as.py}, label = {cd:shape_sim_meas_compare_poly_second.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
# 	Diese temporäre Variable muss immer positiv sein, was durch die IF Abfrage sichergestellt ist, da dies sonst die Differenzvariable verfälscht. Danach wird die Differenzvariable mit der temporären Variable addiert. Es wird nun die Gesamtanzahl der Punkte berechnet, welche identisch mit der Anzahl der berechneten Winkel ist. Zuletzt wird diese mit der Differenzvariable im \lstinline|options| Dictionary gespeichert. 
# 	\lstinputlisting[basicstyle=\ttfamily\scriptsize,firstnumber=22, linerange={53,54,56-59,61-63}, caption={Ausschnitt 3 aus \protect\lstinline|calc_shape_similarity_compare_polygons| Funktion in sha\-pe\_sim\_me\-as.py}, label = {cd:shape_sim_meas_compare_poly_third.py}]{../Code/Shape_Similiarity/shape_sim_meas.py} 
# 	Die statistischen Auswertungen, werden alle im Dictionary (siehe Listing \ref{cd:shape_sim_meas_compare_poly_third.py}) in Radiant und Degree gespeichert. Hier wird  die Winkeldifferenz über alle Frames und Polygone, die durchschnittliche Winkelabweichung der pro Polygon und pro Winkel in das Dictionary geschrieben. Außerdem wird noch die Gesamtanzahl der erkannten Punkte gespeichert, die der Anzahl der Winkel entspricht, da zu jedem Punkt in den Polygonen ein Winkel berechnet wurde. \\
	
# 	Danach wird die Winkelabweichung mit der Methode in Listing \ref{cd:shape_sim_meas_one_frame_first.py} berechnet, welche alle Polygone der gleichen Klasse in einem Frame miteinander vergleicht. Der Messwert wird dadurch berechnet, dass über alle Frames iteriert wird.
# 	\lstinputlisting[basicstyle=\ttfamily\scriptsize,linerange={70,92,93,95,96,98,99,101,102,104}, caption={Ausschnitt aus \protect\lstinline|calc_shape_sim_compare_classes_in_one_frame| Funktion in sha\-pe\_sim\_me\-as.py}, label = {cd:shape_sim_meas_one_frame_first.py}]{../Code/Shape_Similiarity/shape_sim_meas.py} 
# 	Die Methode \lstinline|compare_polygons_in_frame| gibt ein Array zurück, welches die aufsummierten Abweichungen enthält. Dies geschieht indem mit der \lstinline|get_inidzes_and_classes| Methode die Winkelsumme des ersten Polygons jeder Klasse extrahiert wird und in der nächsten Methode \linebreak \lstinline|calc_measures_in_one_frame| diese mit allen anderen Polygonen der gleichen Klasse im Frame verglichen wird. Das Array mit den extrahierten Winkelsummen jeder Klasse wird im folgenden als Referenzklasse bezeichnet.\\
# 	Das Vergleichen geschieht indem, wie in Listing \ref{cd:shape_sim_meas_calc_SSM_one_frame_first.py} als Beispielausschnitt zu sehen, indem über alle Polygone im Frame iteriert wird. Wenn die ClassID, in diesem Fall 2 für Car, mit der des Polygons im Frame übereinstimmt, kann die Differenzvariable berechnet werden. 
# 	\lstinputlisting[basicstyle=\ttfamily\scriptsize,linerange={235,236,247-254}, caption={Ausschnitt 1 aus \protect\lstinline|calc_measure_in_one_frame| Funktion in sha\-pe\_sim\_me\-as.py}, label = {cd:shape_sim_meas_calc_SSM_one_frame_first.py}]{../Code/Shape_Similiarity/shape_sim_meas.py} Diese wird in einem Array gespeichert, welches am Ende zurückgeben wird. Analog geschieht dies für die Klassen Truck und Motorcycle. Wenn keine dieser Klassen erkannt wurde, wird folgende Ausnahme behandelt (siehe Listing \ref{cd:shape_sim_meas_calc_SSM_one_frame_second.py}). 
# 	\lstinputlisting[ basicstyle=\ttfamily\scriptsize, firstnumber=11, linerange={267-275}, caption={Ausschnitt 2 aus \protect\lstinline|calc_measure_in_one_frame| Funktion in sha\-pe\_sim\_me\-as.py}, label = {cd:shape_sim_meas_calc_SSM_one_frame_second.py}]{../Code/Shape_Similiarity/shape_sim_meas.py} 
# 	Aus dem Array mit den Referenzvariablen wird, falls vorhanden, die Winkelsumme abgerufen. Wenn diese Winkelsumme nicht vorhanden ist, wird dem Array der Differenzvariable 0 addiert um diese nicht zu ändern. Sonst wird analog zum obigen Verfahren der Messwert berechnet, nur mit der Änderung das die ClassID zu jedem Wert gespeichert wird, um die Vergleichbarkeit zu gewährleisten. \\
# 	Damit ist das Erstellen der Arrays und die Schleife in Listing \ref{cd:shape_sim_meas_calc_SSM_one_frame_first.py} abgeschlossen. Diese Arrays werden aufsummiert. Bei Objekten, welche nicht den drei Hauptklassen entsprachen, wird mit einer Methode, welche die berechneten Werte in einzelne Arrays für jede detektierte Klasse sortiert (ähnlich zu Bucketsort), die Winkelabweichung berechnet. Für eine nähere Beschreibung siehe Anhang \ref{cd:listing_shape_sim_meas.py} ab Zeile 125. \todo{genauer beschreiben?} Eine Berechnung ist falsch, wenn nur ein Element einer Klasse pro Frame detektiert wurde, da die Winkeldifferenz dann immer 0 beträgt. Falls dies der Fall ist, wird dies im Results Dictionary für die jeweilige Klasse mitgeteilt.
# 	Wenn alle Werte in das Result Dictionary geschrieben wurden, wird dieses als Textdatei abgespeichert und das Programm ist vollständig abgeschlossen.