%!TEX root = ../thesis.tex
\chapter{Theoretischer Hintergrund}
\label{ch:Theoretischer Hintergrund}
{Die Einführung in den theoretischen Hintergrund dieser Arbeit umfasst die Erläuterung der Aufbereitung der Daten mit einem Maschinellem Lernverfahren, namens YOLO, und eine Einführung in die \glqq Discrete Curve Evolution\grqq{}.
}



\section{Maschinelles Lernen}
{	Vorbemerkungen hier Erklärung von Abkürzungen etc.
	\subsection{Vorbemerkungen}
	\subsection{You Only Look Once (YOLO)}
	\begin{list}{-}{Quelle: \citet{Plastiras2018}}
		\item Intro
			\item Objekterkennung, -einordnung und -wirkung im Blick des Menschen ist intuitiv. unsere Augen im Zusammenspiel mit unserem Gehirn ermöglichen es uns schnell und genau zu sehen. Wir können daher schwierige Aufgaben, wie Fahrradfahren mit nur wenigen bewussten Gedanken ausüben.
			\item Computern kann dies mit schnellen und genauen Algorithmen zur Objekterkennung beigebracht werden
			\item Klassifikatoren werden von aktuellen Systemen eingesetzt
			\item Diese nutzen einen Klassifikator zur Objekterkennung und dieser wird an verschieden Stellen in variablen Skalierungen im Testbild angewendet
			\item Es gibt außerdem Systeme wie R-CNN sagen erst Regionnen voraus, um potentielle Bounding Boxen im Bild zu erzeugen, worauf dann ein Klassifikator angewendet wird. Diese Bounding Boxes werden feiner durch eine Nachprozessierung und durch das Eliminieren von doppelten Erkennungen und einer Einordnung basierend auf der Grundlage der anderen im Bild vorhandenen Objekterkennung 
			\item Dies ist sehr langsam und nicht leicht auf Performance zu optimieren (da jeder Teilschritt einzeln trainiert werden muss)
			\item YOLO nutzt Objekterkennung als ein einziges Regressionsproblem. Direkt von Bildpixel zu Bounding Box Koordinaten und Klassenwahrscheinlichkeiten
			\item "You Only Look Once" (YOLO) analysiert nur einmal ein Bild und sagt sofort vorher, welche Objekte wo vorhanden sind
			\item Dadurch ist YOLO sehr einfach, wie in Abb. 1 zu sehen. Ein "Single Convolutional Network"(S-CNN) berechnet gleichzeitig mehrere Bounding Boxen und Klassifizierungswahrscheinlichkeiten für diese
			\item YOLO ist mit ganzen Bildern trainiert worden und optimiert dadurch direkt die Performance zur Objekterkennung
			\item Durch das vereinheitlichte Modell entstehen mehrere Vorteile gegenüber den traditionellen Objekterkennungsmethoden
			\item Erstens: Performance; YOLO ist sehr schnell, da Framedetection als Regresssionsproblem verstanden wird, benötigt man keine komplizierte Pipeline. Das Neuronale Netz wird zum Testzeitpunkt auf ein neues Bild angewendet, um Objekte zu erkennen. YOLO erreicht mehr als das Doppelte der durchschnittlichen Genauigkeit anderer Echtzeitobjekterkennungssysteme (Real Time?)
			\item Zweitens: YOLO analysiert ein Bild global mit Vorhersagen zur Objekterkennung. Durch diese Gesamtbildanalyse kann YOLO während der Training- und Testzeit implizit kontextuelle Informationen über die Klassen und deren Aussehen sammeln. Die Anzahl der Fehler von YOLO beim Verwechselnl von Hintergrund und Objekten im Vordergrund ist weniger als halb so hoch wie bei Fast R-CNN, weil YOLO einen größeren Kontext hat
			\item Drittens: YOLO ist mit  generalisierte Repräsentationen von Objekten trainiert. Die Fehlertoleranz ist bei der Anwendung auf neue Bereiche und unerwartete Eingaben sehr viel größer, da es in hohem Maße verallgemeinerbar ist.
			\item Nachteil von YOLO ist die Genauigkeit. Es hat Schwierigkeiten einige Objekte, insbesondere kleinere, genau zu lokalisieren, obwohl es sonst sehr schnell ist.
			\item Die Trainingsdaten und der Quellcode von YOLO sind Open Source. Es sind außerdem mehrere vortrainierte Modelle zum Download verfügbar.
		\item Unified Detection
			\item YOLO bündelt alle einzelnen Teile der Objektdetektion in ein einzelnes neuronales Netz. Um jede Bounding Box vorherzusagen, benutzt dieser Algorithmus Features vom gesamten Bild. Dadurch das alle Bounding Boxes für alle Klassen im gesamten Bild gleichzeitig vorhergesagt werden, detektiert das Netzwerk global über alle Objekte und im gesamten Bild. Dieses Algorithmendesign ermöglicht ein 'End to End' Training mit Real-Time Geschwindigkeit unter hoher durchschnittlicher Genauigkeit.
			\item Bild wird in $S \times S$ Gitter unterteilt. Eine Gitterzelle ist für die Erkennung des Objektes zuständig, wenn der Mittelpunkt eines Objektes in diese fällt.
			\item $B$ Bounding Boxen und  ihre jeweiligen Confidence Scores werden für jede Gitterzelle vorhergesagt. Der Confidence Score, wie sicher sich das Modell ist, dass die Bounding Box ein Objekt dieser Klasse enthält und für wie genau das Modell diese Vorhersage hält. Dieser Confidence Score ist formal folgendermaßen definiert: FORMEL. Dieser Wert ist 0, wenn kein Objekt in der Zelle existiert. Im anderen Fall ist der Confidence Score gleich zu der 'Intersection over Union' zwischen der vorhergesagten Box (predicted Box) und der Grundwahrheit (Ground Truth)
			\item Jede Bounding Box besteht aus 5 Variablen, die vorhergesagt werden: x,y,w,h und der Confidence. Das Zentrum der Bounding Box wird durch die (x,y) Koordinate dargestellt, welche relativ zu den Grenzen der Gitterzelle sind. (w,h) werden relativ zum gesamten Bild berechnet. Die Confidence stellt, die IOU zwischen der vorhergesagten Box und einem beliebigen Teil der Grundwahrheit dar.
			\item Die durch C bedingten Klassenwahrscheinlichkeiten, welche abhängig davon sind, ob eine Gitterzelle ein Objekt enthält, werden auch durch jede Zelle vorhergesagt: FORMEL. 
			\item Pro Gitterzelle wird die Anzahl der Klassenwahrscheinlichkeiten unabhängig von der Bounding Box Anzahl B berechnet.
			\item Die bedingten Klassenwahrscheinlichkeiten werden zum Testzeitpunkt mit den Confidence Scores der einzelnen Bounding Boxes multipliziert, was einen klassenspezifischen Confidence Score für jede Bounding Box ergibt. Dies geschieht mit folgender FORMEL. Dieser Wert enthält nicht nur die Wahrscheinlichkeit, dass diese Klasse in der Bounding Box vorkommt, sondern auch wie gut das die vorhergesagte Box mit dem detektierten Objekt übereinstimmt. Ein Beispielablauf ist in Abbildung 2 zu sehen
			\item 
			\item 
			\item Network Design
				\item Das vollständig Netzwerk ist in Abbildung 3 zu sehen. 
				\item Dieses Model ist als CNN implementiert worden. Die Merkmale des Bildes werden in den ersten Schichten der CN Layer des Netzes detektiert. Die (Ausgabe-)Wahrscheinlichkeiten und Koordinaten werden von den 'Fully Connected Layers' vollständig verbundenen Layern generiert.
				\item GoogLeNets Modell für Bildklassifizierung hat die Netzwerkarchitektur von YOLO beeinflusst. Das Netzwerk von YOLO hat 24 Convolutional Layers, an welche 2 'Fully Connected Layers' anschließen.
				\item Es wird ein $1 /times 1$ 'Reduction Layer' gefolgt von  $3 /times 3$ 'Convolutional Layers' eingesetzt.
				\item Außerdem existiert eine schnelle Version von YOLO, die ein neuronales Netz mit weniger Schichten (9 statt 24) und weniger Filtern in diesen verwendet. YOLO und Fast YOLO gleichen sich abgesehen ovn der Größe des Netzwerkes vollständig in den Trainings- und Testparametern.
				\item Die finale Ausgabe dieses Netzes ist ein 7 x 7 x 30 Tensor mit Vorhersagen
			\item Training 
			\item Inference ?
			\item Limitations of YOLO
				\item Da jede Gitterzelle nur 2 Bounding Boxen vorhersagen und eine Klasse haben kann, unterliegt YOLO einer räumlichen Einschränkung. Dies begrenzt die Anzahl der benachbarten Objekte, die das Modell vorhersagen kann. Außerdem ist es für das Modell schwierig, kleine Objekte, die in Gruppen auftreten zu detektieren. Eine weitere Herausforderung ist, dass Objekte mit neuen oder ungewöhnlichen Formen auftreten können und dadurch die Vorhersage erschwert wird. Da die Netzwerkarchitektur aus mehreren 'Downsampling' Schichten besteht, benutzt das Modell relativ grobe Features zur Vorhersage der Bounding Boxen. Außerdem sorgt das Training mit einer Verlustfunktion, die die Erkennungsleistung annähert, dafür das Fehler bei kleinen Bounding Boxen genauso wie bei großen Bounding Boxen behandelt. Dies ist ein Nachteil, weil ein kleiner Fehler in einer großen Box meistens harmlos ist, aber ein kleiner Fehler in einer kleinen Box eine sehr viel größer Auswirkung auf die IOU hat. Falsche Lokalisierungen sind eine weitere Hauptfehlerquelle.
				\item  
		\item Comparison to Other Detection Systems (X)
		\item Experiments (X)
		\item Real-Time-Detection in the Wild (X)
		\item Conclusion
	\end{list}
	
}



\section{Discrete Curve Evolution (DCE)}
\label{sec:Discrete Curve Evolution}
{Die \glqq Discrete Curve Evolution\grqq{} (DCE, \cite{Latecki1999a,Latecki1999c}) ist eine Methode zur Polygonvereinfachung, die die Formähnlichkeit des Polygons beibehält und XXXX von YYYY vorgestellt wurde. Im Folgenden wird diese Methode genauer erläutert \citep{Barkowsky2000}. 
\\
Die Vereinfachung von Polygonen, während die Form der Polygone erkennbar bleibt und kleinere Knicke verschwinden, ist die wichtigste Eigenschaft der DCE. Dies basiert auf der schrittweisen Entfernung von Punkten, die den geringsten Beitrag zur Form des Polygons leisten. Dieser Beitrag des einzelnen Punktes zur Form des Polygons kann in einem Relevanzmaß gemessen werden \citep{Barkowsky2000}. 
\\
\begin{figure}[ht]
	   \centering
	   \includegraphics*[scale = 0.8, keepaspectratio, trim=2 2 2 2 ]{images/schem_maps_paper_kinks.png}
	   \caption[Beispielpolygone für die Erläuterung der Relevanz des Knicks]{Beispielpolygone für die Erläuterung der Relevanz des Knicks. Die fettgedruckten Knicke stellen die betrachteten Liniensegmente dar \citep{Barkowsky2000}.} 
	   \label{Bsp_Rev_Measur_K}
\end{figure}In Abbildung \ref{Bsp_Rev_Measur_K} ist ein Beispiel zu sehen. Bei diesen Formen sind die Knicke durch den Fettdruck zu erkennen. Der Knick in (a) kann als irrelevante Formänderung interpretiert werden, während die Knicke in (b) und (c) deutlich stärker zu erkennen sind. Diese beiden Knicke leisten einen relevanten Beitrag zur Form des Polygons. Der Knick in (d) hat jedoch den größten Anteil an der Form des Beispielobjektes \citep{Barkowsky2000}. 
\\
Diese Unterschiede zum Beitrag eines einzelnen Punktes zur Form eines Polygons lässt sich durch existierende geometrische Konzepte erklären. Wenn man den Knick in Abbildung \ref{Bsp_Rev_Measur_K} (a) mit (b) vergleicht, ist zu erkennen, dass (b) den gleichen Winkel hat wie (a). Der Unterschied ist jedoch, dass die Strecken bei (b) länger sind. Dies erhöht den Beitrag des Punktes in (b) zur Form des Polygons im Vergleich zu dem Punkt in (a).
Der Knick in (c) hat einen größeren Winkel im Vergleich zu (a). Die Länge der Strecken ist jedoch gleich. Bei dem Knick in (d) ist deutlich zu erkennen, dass dieser den signifikantesten Anteil zur Form des Polygons leistet. Dies ist durch den größten Winkel in Verbindung mit den längsten Strecken zwischen Punkten gegeben \citep{Barkowsky2000}.
\\
Dieses Beispiel zeigt, dass die Relevanz jedes Knicks für ein Polygon durch den Winkel und die Länge der an den Punkt anschließenden Liniensegmente definiert werden kann. Je größer der Winkel und die Länge der Liniensegmente sind, desto wichtiger ist der Beitrag des Knicks zur Form der Kurve. Aus diesen Beobachtungen kann eine Funktion K gebildet werden, die den Beitrag eines Knicks zur Form des Polygons misst. Diese sollte monoton steigend sein, wenn die Länge der benachbarten Liniensegmente wächst und der Winkel größer wird \citep{Barkowsky2000}.
\\
Eine formale Definition dieser Funktion kann folgendermaßen erfolgen. Zwei konsekutive Liniensegmente werden als $S_1, S_2$ definiert. Das Maß für die Relevanz des Knicks K, welches aus $S_1 \cup S_2$, dem Winkel  $\beta(S_1, S_2)$ am Scheitelpunkt von $S_1,  S_2$ und den Längen von $S_1, S_2$ besteht, kann nach folgender Formel berechnet werden (nach \citet{Latecki1999a}):
\\
\begin{equation}
	K(S_1,S_2) = \frac{\beta(S_1,S_2)l(S_1)l(S_2)}{l(S_1) + l(S_2)} 
	\label{Equ_K_Bark} 
\end{equation}
 Hier ist $l$ als Funktion definiert, welche die Länge des Segments berechnet. \\
 Der Vorteil dieser Formel ist, dass je höher der Wert von $K(S_1, S_2)$ ist, desto größer ist der Beitrag des Knicks von $S_1 \cup S_2$ zur Form des Polygons \citep{Barkowsky2000}.
 \\
 Nun wird der Prozess der \glqq Discrete Curve Evolution\grqq{} beschrieben.\\ Das Minimum der Kostenfunktion \ref{Equ_K_Bark} ergibt ein Tupel von Liniensegmenten, welches durch eine einzelne Linie ersetzt wird, indem ihre Endpunkte verbunden werden. Dies beschreibt eine Iteration der DCE. Dies wird für jede sich daraus neu ergebene Form wiederholt, indem $K$ für jeden Punkt immer neu berechnet wird \citep{Barkowsky2000}.
 \\ 
 Zusammenfassend ist die DCE folgendermaßen aufgebaut. Der kleinste Wert von $K(S_1,S_2)$ definiert in jedem Iterationsschritt das Paar von konsekutiven Liniensegmenten $S_1, S_2$, welches durch ein einzelnes Liniensegment von den Endpunkten $S_1 \cup S_2$ ersetzt wird. Das Relevanzmaß $K$ wird lokal für jeden Iterationsschritt der DCE neu berechnet und ist deshalb keine lokale Eigenschaft der Form des ursprünglichen Polygons. Dies wird durch die Löschung einiger Liniensegmente im Verlauf der DCE verursacht.\\ Die DCE ermöglicht, wie in Abbildung \ref{Bsp_DCE_Bark_Paper} zu erkennen, die Substitution kleinerer Knicke ohne den Gesamteindruck der Form des Polygons nachhaltig zu verändern \citep{Barkowsky2000}.
 \\
 Ein weiterer Vorteil dieses Algorithmus ist, dass er immer terminiert, da in jedem Iterationsschritt die Zahl der Punkte um eins reduziert wird. Die DCE konvergiert für geschlossene Polygone gegen einen Zustand, wo nur noch drei Liniensegmente im Polygon vorhanden sind. Durch einen Abbruch des Prozesses ist es jedoch möglich, ein Polygon auf eine bestimmte vorgegebenen Punktanzahl zu reduzieren, sodass man ein konvexes Polygon erhält \citep{Barkowsky2000}.
 \begin{figure}[ht]
	   \centering
	   \includegraphics*[scale = 1, keepaspectratio, trim=2 2 2 2 ]{images/schem_maps_paper_DCE.png}
	   \caption[Anwendungsbeispiele für die \glqq Discrete Curve Evolution\grqq{}]{Anwendungsbeispiele für die \glqq Discrete Curve Evolution\grqq{}  \citep{Barkowsky2000}.}
	   \label{Bsp_DCE_Bark_Paper}
\end{figure}

 }

% \blindtext




% \blindmathpaper
% % \Blindtext




% \begin{table}[ht]
% 	\centering
% 	\begin{tabular}{c|c|c}
% 		a & b & c \\ \hline
% 		1 & 2 & 3 \\
% 		1 & 2 & 3 \\
% 		1 & 2 & 3
% 	\end{tabular}
% 	\caption{Eine Tabelle}
% \end{table}

% \begin{figure}[ht]
% 	\centering
% 	\includegraphics[width=0.3\textwidth]{example-image-a}
% 	\caption{Eine Unterschrift}
% \end{figure}

% \begin{figure}[ht]
% 	\centering
% 	\begin{subfigure}[b]{0.45\textwidth}
% 		\includegraphics[width=\textwidth]{example-image-a}
% 		\caption{Eine Unterschrift}
% 	\end{subfigure} \hfill
% 	\begin{subfigure}[b]{0.45\textwidth}
% 		\includegraphics[width=\textwidth]{example-image-b}
% 		\caption{Noch eine Unterschrift}
% 	\end{subfigure}
% 	\caption{Mehr Unterschriften}
% \end{figure}



