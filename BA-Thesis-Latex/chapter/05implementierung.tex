%!TEX root = ../thesis.tex
\chapter{Implementierung} 
\label{ch:implementierung}

	\section{Meta-Ablauf im Programm}{
	\begin{figure}[h]
		\centering
		\includegraphics*[scale = 0.5, keepaspectratio]{images/Ablaufdiagram.png}
		\caption[Programmablaufplan]{Programmablaufplan: Blau ist die EF Version; Gelb die RV Version; Schwarz sind alle Programmteile, die von beiden Versionen genutzt werden (Quelle: eigene Darstellung)}
		\label{pic:Programmablaufplan}
	\end{figure}

	Der Programmablauf ist folgendermaßen geplant. Ein Ablaufdiagramm ist in Abb. \ref{pic:Programmablaufplan} zu sehen. \\  Der erste Schritt besteht darin, dass Video einzulesen und dann mit der jeweiligen YOLO Implementierung zu analysieren. Danach wird im zweiten Schritt auf alle von YOLO segmentierten Objektumrisse die DCE angewendet. Diese werden, bis zu einer bestimmten vorher festgelegten Punktanzahl, vereinfacht. Hier unterscheiden sich die beiden YOLO Implementierungen, dahingehend, dass die Result Version direkt das Video vollständig mit YOLO analysiert und die Every Frame Version jedes Frame einzeln extrahiert, mit YOLO analysiert und die jeweiligen detektieren Objektumrisse vereinfacht. Als letzten Schritt werden diese vereinfachten Umrisse ins Video, bzw. den jeweiligen Frame, eingefügt, um das Frame und Ursprungspolygon zu überschreiben. Danach wird das Formähnlichkeitsmaß berechnet und als Endprodukt ein anonymisiertes Video ausgegeben. 
	}


%\clearpage

\section{Implementierung in Python} 
{\label{implementation_in_python}} 
Im Folgenden wird die Implementierung erläutert. Die angegebenen Listings sind zum einfachen Verständnis gekürzt und ohne Kommentare. Für ein Listing des gesamten Codes mit Kommentaren s. Anhang \ref{cd:gesamt_listing}. Der Code ist außerdem auf Github veröffentlicht \citep{Lietmeyer2023}.\\ 
EF Version ist die Abkürzung für \glqq Every Frame\grqq{} Version (1. YOLO Variante) und RV Version ist die Abkürzung für \glqq Result\grqq{} Version (2. YOLO Variante), die direkt mit einem von YOLO generierten Objekt arbeitet. 
\subsection{Main File}
{ 
	Das Main File importiert alle Unterskripte, da es auf die Funktionen zugreifen muss, um das Video zu verarbeiten und zu schreiben. Diese Unterskripte sind: 
	\begin{itemize}
		\item yolo\_every\_frame.py (s. Kap. \ref{py:YOLO_every_frame})
		\item yolo\_result\_version.py (s. Kap. \ref{py:YOLO_res_vers})
		\item DCE.py (s. Kap. \ref{py:DCE})
		\item shape\_sim\_meas.py (s. Kap. \ref{py:Shape_Sim_Meas})
	\end{itemize}
	Dazu wird die Erweiterung CV2 (s. Kap. \ref{subsec:Computer_Vision_2}) eingelesen, um das Video aus einzelnen Frames zu generieren.\\
	Die Main Methode besteht aus einer Dictionary Variable \lstinline|options|, in der alle Einstellungen für die Verarbeitung des Videos gesetzt werden. Hier werden auch die einzelnen Zeitstempel gespeichert. \ifimportant Ein Ausschnitt ist in Listing \ref{cd:part_of_options_var} zu sehen. \fi \\
	In diesem werden die Lese- und Schreibpfade für das Quell- und Ergebnisvideo festgelegt, sowie der Pfad für die Textdatei, die die Timestamps enthält. In den nächsten Zeilen kann festgelegt werden, auf bis viele Punkte die von YOLO detektierten Objekte reduziert werden. Diese werden in 4 unterschiedliche Objekttypen unterteilt: Auto (Car), Motorrad (Motorcycle), LKW (Truck) und andere Objekte (other\_Object). \\
	Des Weiteren wird das genutzte YOLO Modell definiert und festgelegt, ob nur die vereinfachten Umrisse der erkannten Objekte ausgegeben werden. Außerdem kann gesteuert werden, ob die von YOLO detektierten Objektboundingboxen schwarz ausgefüllt werden, sodass der Umriss klarer erkannt wird. Hier kann auch die Ausgabe der Labels gesteuert werden, diese beinhalten die Information, was für eine Klasse, bzw. Objekt, detektiert wurde und wie hoch der Confidence Score ist. \\
	Standardmäßig ist die Version des Codes ausgewählt, die das Video erst vollständig von YOLO analysieren lässt, dies lässt sich mit der \lstinline|yolo_every_frame| Boolean umstellen. Die letzte Boolean beschreibt, ob Zeitstempel gesetzt werden sollen. Dieses Dictionary hat weitere Einträge, die der Verwaltung der verschiedenen Zeitstempel und weiterer Messwerte dienen. \\
	\ifimportant
	\lstinputlisting[style=intext, linerange={338,339-342,344-346,348-351,353-357,359}, caption={Ausschnitt aus der \protect\lstinline|options| Variable in  Main.py}, label = {cd:part_of_options_var}]{../Code/main.py}
	\fi	Im weiteren Verlauf wird dann ausgewählte Version des Codes gestartet und beim Abschluss das Video und die Textdatei in die entsprechenden Pfade geschrieben.
	Es existieren außerdem Funktionen, um die Testfälle zur Evaluation mit einem Programmdurchlauf zu generieren und die \lstinline|options| Variable wieder auf ihre Standardwerte zurückzusetzen. Dies ist erforderlich um für Testfälle andere Einstellungen festlegen zu können, wenn mehrere Testdurchläufe aufeinanderfolgend in einer Funktion gestartet werden.
}



\subsection{1. YOLO Variante (EF Version)} {
	\label{py:YOLO_every_frame}
	In dieser Variante wird das Video in einzelne Frames mit CV2 zerlegt, auf die dann jeweils der ausgewählte YOLO Algorithmus angewendet wird. Der Fortschrittsbalken bildet anhand der durchlaufenden Frames den Berechnungsfortschritt ab. 
	Es wird über alle Frames des Videos iteriert, in der das jeweilige Frame aus dem Video extrahiert wird und dann an die Methode übergeben wird, die YOLO anwendet. 
	\ifimportant
	\lstinputlisting[style=intext,linerange={41,43,45,46,48,50,56}, caption={Ausschnitt aus yolo\_every\_frame.py}, label = {cd:part_of_yolo_every_frame.py}]{../Code/YOLO/yolo_every_frame.py}\fi	Dies geschieht, indem zuerst die Gesamtanzahl der Frames in der \lstinline|framecounter| Variablen gespeichert wird, welche den Iterator für die Schleife limitiert\ifimportant \ (s. Listing \ref{cd:part_of_yolo_every_frame.py})\fi. \\ 
	In der Schleife wird das jeweilige Frame an der \lstinline|i|-ten Stelle als Bilddatei in der \lstinline|img| Variablen gespeichert. Dieses wird dann im nächsten Schritt der Funktion übergeben, die das Bild mit YOLO analysiert und zurückgibt. Ein vorher festgelegtes Array speichert dann alle analysierten Bilder. \\ 
	Wenn die Schleife terminiert, wird das Array aus Bildern zu einem Video zusammengesetzt und gespeichert. \\
	\ifimportant
	\lstinputlisting[style=intext,linerange={66,77,84,96,98,103,104,106,115,116,118,119,127-129,131,132}, caption={Ausschnitt aus der \protect\lstinline|run_yolo| Funktion in yolo\_every\_frame.py}, label = {cd:run_yolo_func_in_yolo_every_frame.py}]{../Code/YOLO/yolo_every_frame.py}
	\fi Die \lstinline|run_yolo| Funktion beginnt mit dem Festlegen des YOLO Modells \ifimportant (s. Listing \ref{cd:run_yolo_func_in_yolo_every_frame.py})\fi. Danach wird der Frame von YOLO analysiert, welches in der yo\-lo\-\_seg\-men\-tat\-ion.py erfolgt. Hier wird ein Objekt zurückgeben, welches die Boundingboxen der detektierten Objekte, die jeweiligen Klassen, die segmentierten Umrisse und den jeweiligen Confidence Score enthält. \\
	Dieses Objekt wird in der darauffolgenden Schleife durchlaufen. Hier werden zunächst die Koordinaten der jeweiligen Boundingbox gesetzt und im nächsten Schritt werden die Umrisse mit der DCE vereinfacht (für eine genauere Beschreibung in der Theorie s. Kap. \ref{sec:Discrete Curve Evolution} und im Code s. Kap. \ref{py:DCE}). 
	Zuvor wird noch die Variable abgefragt, ob die Boundingboxen der erkannten Objekte mit schwarzen Pixeln gefüllt werden sollen. Mit CV2 werden danach die Boundingboxen und die Umrisse der Polygone gezeichnet. Für den Fall, dass die \lstinline|write_Labels| Variable im \lstinline|options| Dictionary auf True gesetzt ist, werden im nächsten Schritt der Confidence Score und die Class ID über die Boundingbox geschrieben. \\
	Zur Evaluation werden im nächsten Schritt die Winkelsummen für jedes Polygon summiert und in einem Array im \lstinline|options| Dictionary gespeichert. \\
	Wenn alle Frames des Videos durchlaufen wurden, werden die einzelnen Frames wieder zu einem Video zusammengesetzt und statistische Auswertungen (s. Kap. \ref{py:Shape_Sim_Meas}) durchgeführt. Damit ist dieser Abschnitt des Programmes abgeschlossen.\\
	\ifimportant
	\lstinputlisting[style=intext,linerange={31,37,46-48,59,61-64,68,70,72,73}, caption={Ausschnitt aus  yolo\_segementation.py}, label = {cd:yolo_in_yolo_segmentation.py}]{../Code/YOLO/yolo_segmentation.py}
	\fi yolo\_segmenation.py basiert auf einer Entwicklung von \citeauthor{Canu_pysource} \citep{Canu_pysource} und beinhaltet einige Abänderungen. \ifimportant Der Code, auf den sich im Folgenden bezogen wird, ist in Listing \ref{cd:yolo_in_yolo_segmentation.py} zu sehen. \fi Hier wird nach der Initialisierung des YOLO Modells die Detektionsfunktion ausgeführt. Diese beinhaltet die Prediction mit YOLO und eine IF Abfrage, wenn keine Objekte von YOLO erkannt wurden. Wenn Objekte erkannt wurden, werden deren Boundingboxen, ClassIDs, Umrisse und Confidence Scores zurückgeben. 
	}

\subsection{2. YOLO Variante (RV Version)}{
	\label{py:YOLO_res_vers}
	Diese Variante des Codes analysiert das Video direkt am Anfang mit YOLO. Dies bietet den Vorteil, dass durch die effiziente Implementierung von YOLO die Gesamtdauer des Programmes verringert wird. Der Fortschrittsbalken bildet bei dieser Implementierung anhand der von der DCE durchlaufenen Polygone den Berechnungsfortschritt ab.  Die Anwendung von YOLO findet direkt in main.py statt. \ifimportant Dies ist in Listing \ref{cd:yolo_result_main.py} zu sehen. \fi
    \ifimportant
	\lstinputlisting[style=intext,linerange={109,115,117,121,125,128,130}, caption={Ausschnitt aus \protect\lstinline|run_yolo_result_version| in main.py}, label = {cd:yolo_result_main.py}]{../Code/main.py}
	\fi	Da hier das gesamte Video in dem von YOLO generierten \lstinline|results| Objekt gespeichert wird, benötigt die Funktion, die das Video verändert nur dieses Objekt und das \lstinline|options| Dictionary. \\
	
	Die \lstinline|get_outline_for_every_object| Funktion \ifimportant (s. Listing \ref{cd:yolo_result_get_outline_for_every_object.py}) \fi läuft folgendermaßen ab. \\
	Die Schleife iteriert über die Gesamtanzahl der Frames im Video. Durch die IF Abfrage wird der Fall abgefangen, dass kein Objekt im Frame erkannt wurde. Wenn ein Objekt erkannt wurde, werden mit der \lstinline|get_data| Funktion die Daten der detektierten Objekte aus dem Frame exportiert. Ansonsten wird das Frame ohne Veränderung überschrieben, wenn das Video im \lstinline|options| Dictionary nicht auf schwarz gesetzt wurde. Die \lstinline|get_data| Funktion basiert auf \citeauthor{Canu_pysource} \citep{Canu_pysource} und ist ähnlich zu der in Kap. \ref{py:YOLO_every_frame} \ifimportant (s. Listing \ref{cd:yolo_in_yolo_segmentation.py}) \fi aufgebaut. \\
	Diese Daten werden in einzelne Variablen abgespeichert. Danach wird auf die Umrisse die DCE (s. Kap. \ref{py:DCE}) angewendet. Mit CV2 werden die vereinfachten Umrisse dann in das Frame gespeichert, indem das gerade betrachtete Frame überschrieben wird. Im weiteren Verlauf wird dann das Frame, bzw. je nach Einstellung nur die Boundingboxen der detektierten Objekte, mit schwarzen Pixeln ausgefüllt. \\
	\ifimportant
	\lstinputlisting[style=intext,linerange={31,38-40, 43-45,47-50,52-53,56,62,64-68}, caption={Ausschnitt 1 aus \protect\lstinline|get_outline_for_every_object| Funktion in yolo\_result\_version.py}, label = {cd:yolo_result_get_outline_for_every_object.py}]{../Code/YOLO/yolo_result_version.py}\fi Die zweite FOR Schleife \ifimportant (s. Listing \ref{cd:yolo_result_get_outline_for_every_object_second.py}) \fi zeichnet für jedes erkannte Objekt im Frame die Boundingbox und die Labels, falls dies im \lstinline|options| Dictionary gesetzt wurde. Außerdem wird noch die Gesamtsumme der Winkel  zur späteren statistischen Auswertung für jedes Polygon berechnet.
	\ifimportant
	\lstinputlisting[style=intext,firstnumber = 21,linerange={70,71,72,74,76,77,80,93,95,96,98,99,102}, caption={Ausschnitt 2 aus \protect\lstinline|get_outline_for_every_object| Funktion in yolo\_result\_version.py}, label = {cd:yolo_result_get_outline_for_every_object_second.py}]{../Code/YOLO/yolo_result_version.py}\fi Wenn die Schleifen durchgelaufen sind, wird das veränderte \lstinline|result| Objekt und das \lstinline|options| Dictionary zurückgeben. Danach wird das Video an dem angegebenen Pfad gespeichert. Es werden statistische Auswertungen (s. Kap. \ref{py:Shape_Sim_Meas}) durchgeführt und die Timestamps gespeichert. Dies ist der letzte Schritt in diesem Teil des  Programmes. \\
	}

\subsection{Discrete Curve Evolution}{
	\label{py:DCE}
	Die folgende Implementierung basiert auf \citeauthor{Barkowsky2000} \citep{Barkowsky2000} (s. Kap. \ref{sec:Discrete Curve Evolution}). Die DCE wird durch ähnlich implementierte Funktionen in beiden YOLO Implementierungen gestartet.  \ifimportant Als Beispiel wird hier die Implementierung aus yolo\_result\_version.py genutzt. Diese ist in Listing \ref{cd:yolo_result_run_DCE.py} zu sehen. \fi \\
	\ifimportant
	\lstinputlisting[style=intext,linerange={107,116-126}, caption={Ausschnitt aus \protect\lstinline|run_DCE| Funktion in yolo\_result\_version.py}, label = {cd:yolo_result_run_DCE.py}]{../Code/YOLO/yolo_result_version.py}
	\fi Hier wird in einer FOR Schleife, die über alle Polygone iteriert,  anhand der erkannten Klassen Auto, Motorrad und LKW die Methode zur Polygonvereinfachung mit einer festen Punktgrenze ausgeführt. Dies passiert auch, falls das detektierte Objekt nicht zu diesen drei Klassen gehört. \\ 
	Zurückgegeben wird ein Array, welches die vereinfachten Umrisse von jedem Objekt enthält, da das Ursprungspolygon immer mit dem vereinfachten Polygon überschrieben wird. \\

	\subsubsection{Implementierung der K Wert Berechnung \label{impl:Calc_K_Val}} 

	Der K Wert wird in der folgenden Funktion \lstinline|calc_k_with_points| berechnet. Diese Methode basiert auf der Formel \ref{Equ_K_Bark} (nach \citet{Latecki1999a}) und ist dahingehend abgeändert worden, dass diese nicht mit Liniensegmenten, sondern mit drei Punkten berechnet werden kann. Die abgeänderte Formel lautet:
	\begin{equation}
		K(p,S_1,S_2) = \frac{\beta(p, S_1, S_2)l(p, S_1)l(p, S_2)}{l(p, S_1) + l(p, S_2)} 
		\label{equ_K_DCE_points}
	\end{equation}
	Im Programmcode ist dies folgendermaßen implementiert (s. Listing \ref{cd:DCE_calc_k_with_points.py}). Als Eingabe wird das Polygon, der betrachtete Punkt (\lstinline|p|), der folgende (\lstinline|s1|) und der vorherige (\lstinline|s2|) Punkt erwartet. Die Reihenfolge von betrachteter, folgender und vorheriger Punkt bei der Parameterübergabe kann aufgrund von Sonderfallbehandlung in den Beschreibungen in Kap. \ref{impl:DCE_SimplyfierFunc} abweichen. \\ 
	Es wird zunächst der Winkel $\beta$ berechnet, indem alle drei Punkte und das Polygon übergeben werden. Danach werden die beiden Distanzen zwischen $p, S_1$ und $p, S_2$ berechnet. Die Winkelberechnungsfunktion arbeitet mit NumPy und die Distanzberechnungsfunktion basiert auf Funktionen, die GeoPandas bietet.
	\lstinputlisting[style=intext,linerange={203,217-219,221,222}, caption={Ausschnitt aus \protect\lstinline|calc_k_with_points| Funktion in DCE.py}, label = {cd:DCE_calc_k_with_points.py}]{../Code/DCE/DCE.py}
	Diese drei Werte werden dann analog zur Formel \ref{equ_K_DCE_points} zum Wert K berechnet. Als letzten Schritt wird dieser Wert und der Winkel als Array zurückgegeben. \\
	Die Winkelberechnungsfunktion arbeitet mit dem Arcustangens und $\pi$ \ifimportant (s. Listing \ref{cd:DCE_angle_and_distance.py})\fi. Dies basiert auf der Dokumentation von NumPy \citep{numpy_angle}. Da die Berechnung ein Array ausgibt, müssen alle Elemente aufsummiert werden, um einen Wert zu erhalten. Dieser Wert wird dann in Radiant umgerechnet und zurückgeben. \\
	Die Distanzberechnung erfolgt mit einer Funktion, die GeoPandas bei \lstinline|Geopanda.Geoseries| Objekt bietet. Diese errechnet die Distanz zwischen den Punkten \lstinline|p1| und \lstinline|p2|. Danach wird diese zurückgegeben.
	\ifimportant
	\lstinputlisting[style=intext,linerange={325,337-339,349,350,352,353,357,374,383-386}, caption={Ausschnitte aus \protect\lstinline|get_angle_two_lines| und \protect\lstinline|get_distance_between_two_points| Funk\-tio\-nen in D\-C\-E\-.py}, label = {cd:DCE_angle_and_distance.py}]{../Code/DCE/DCE.py}
	\fi

	\subsubsection{Implementierung der Vereinfachungsfunktion \label{impl:DCE_SimplyfierFunc}}

	Nun wird der Prozess innerhalb der DCE.py Datei genauer erläutert\ifimportant \ (s. Listing \ref{cd:DCE_simplify_polygon_A1.py} - \ref{cd:DCE_simplify_polygon_A4.py})\fi. Es ist zu beachten, dass die Berechnungsfunktion nur mit den Indizes für die Punkte des Polygons arbeiten, sodass die Punkte nicht direkt angesteuert werden können. Da die DCE in dieser Arbeit mit GeoPandas (s. Kap. \ref{subsec:Geopandas}) implementiert wurde, muss das Array zuerst in ein \lstinline|Geopandas.Geoseries| Objekt transformiert werden. \\
	Danach kann von diesem Polygon die Gesamtpunktanzahl berechnet werden und der Fall abgefangen werden, dass ein Polygon bereits weniger Punkte als die Punktanzahl, auf die das Polygon reduziert werden soll, hat. Außerdem wird hier der Fall abgefangen, dass ein Polygon aus 3 Punkten besteht, da dies die geringstmögliche Vereinfachung ist, die im Frame von CV2 gerendert werden kann. \\
	\ifimportant
	\lstinputlisting[style=intext,linerange={47,56-57,59-63}, caption={Ausschnitt 1 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A1.py}]{../Code/DCE/DCE.py}
	\fi	Es folgt die Berechnung der K Werte für alle Punkte\ifimportant \ (s. Listing \ref{cd:DCE_calc_k_for_all_points.py})\fi, indem das Polygon einmal vollständig durchlaufen wird. Diese werden in einem zweidimensionalen Array gespeichert. Dieses Array enthält Tupel, die an erster Stelle den Index des Punktes im Polygon speichern und an zweiter Stelle den für diesen Punkt berechneten K-Wert. Danach wird dieses Array in ein NumPy Array umgewandelt, damit die Funktionen der Bibliothek auf dieses angewendet werden können. Als nächsten Schritt wird dieses Array nach dem zweiten Index, dem K-Wert für jeden Punkt, sortiert, sodass der Index mit dem geringsten K-Wert an der ersten Stelle des Arrays steht. Hierzu wird das Quicksort-Verfahren (s. Kap. \ref{subsec:NumPy}), welches NumPy bereits integriert hat, genutzt. \\
	\ifimportant
	\lstinputlisting[style=intext,firstnumber=9, linerange={65,66,68,69,71,72,73,74}, caption={Ausschnitt 2 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A2.py}]{../Code/DCE/DCE.py}
	\fi
	Im weiteren Verlauf folgt eine WHILE Schleife \ifimportant(s. Listing \ref{cd:DCE_simplify_polygon_A1.py}) \fi in der zuerst der Index des Punktes mit dem geringsten K abgespeichert wird. Anhand dieses Index können nun die neuen K-Werte nach einer Entfernung dieses Punktes berechnet werden. Dieser Punkt wird nun aus dem Polygon entfernt, sodass im weiteren Verlauf die neuen K-Werte berechnet werden können. Es wird nun die neue verringerte Punktzahl des Polygons abgespeichert. \\
	Nun werden verschiedene Sonderfälle zur Berechnung erklärt. Der erste Sonderfall ist, dass \lstinline|indic|, der Index des Punktes mit dem geringsten K-Wert,  dem Wert 0 entspricht. Daraus kann der vorherige K-Wert \lstinline|k_bef| berechnet werden, indem als betrachteter Punkt der letzte Punkt des Polygons (Index: \lstinline|NoP_temp-1|) mit den Nachbarpunkten (als Index) \lstinline|0|  als folgender Punkt und \lstinline|NoP-2| als vorherigen Punkt der Berechungsfunktion übergeben wird. \\
	Bei der Berechnung des K-Wertes für den aktuellen Punkt \lstinline|k_act| muss als Parameter der erste Punkt des Polygons (Index: \lstinline|0|), der vorherige Punkt (\lstinline|NoP-1|) und \lstinline|1| als folgenden Punkt der K-Berechnungsfunktion (s. Kap. \ref{impl:Calc_K_Val}, Listing \ref{cd:DCE_calc_k_with_points.py}) übergeben werden. \\
	\ifimportant
	\lstinputlisting[firstnumber=17, style=intext, linerange={76,77,78,79,80,81,82,84,85,86,87}, caption={Ausschnitt 3 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A3.py}]{../Code/DCE/DCE.py}
	\fi
	Wenn \lstinline|indic| nicht dem Wert 0 entspricht, wird folgendermaßen verfahren\ifimportant \ (s. Listing \ref{cd:DCE_simplify_polygon_A3.py})\fi.
	Es wird zunächst der Fall behandelt, dass \lstinline|indic-1| dem Wert 0 entspricht. Wenn dies der Fall ist, muss Berechnung von \lstinline|k_bef| angepasst werden, indem für die Übergabeparameter der K-Wert Berechnung, der erste Punkt des Polygons (\lstinline|0|), der folgende Punkt (\lstinline|1|) an zweiter Stelle und der letzte Punkt des Polygons (\lstinline|NoP-1|) an dritter Stelle übergeben werden. \\
	Im ELSE Teil dieser Abfrage werden weitere IF Abfragen genutzt, um den Fall abzufangen, dass \lstinline|indic+1| größer ist als das Polygon Punkte hat, nachdem der Punkt mit dem geringsten K Wert entfernt wurde. In diesem Fall wird \lstinline|k_bef| so berechnet, dass der vorherige Punkt (\lstinline|indic-1|) von \lstinline|indic| mit den Übergabeparameter \lstinline|0| als folgenden und \lstinline|indic| als vorherigen Punkt berechnet wird. Wenn dies nicht der Fall ist, kann \lstinline|k_bef| auf dem vorgesehenen Weg mit den Übergabeparameter \lstinline|(indic-1, indic, indic-2)| berechnet werden. \\

	Nun wird der Sonderfall behandelt, dass \lstinline|indic+1| größer als die Anzahl der Punkte im Polygon nach dem Entfernen des Punktes mit dem geringsten K Wert ist, um \lstinline|k_act| zu berechnen. Diese Variable speichert den aktuellen neuen K-Wert des vorher entfernten Punktes. \\
	Wenn \lstinline|indic+1| größer ist, als die aktuelle Anzahl der Punkte im Polygon, muss die Berechnung dahingehend abgeändert werden, dass als aktueller betrachteter Punkt der K Berechnungsfunktion \lstinline|indic-1| übergeben wird, mit dem ersten Punkt (\lstinline|0|) des Polygons als ersten Nachbarn und dem vorherigen Punkt (\lstinline|indic-2|) als zweiten Nachbarn. Sollte \lstinline|indic+1| nicht größer als die aktuelle Anzahl der Punkte im Polygon sein, kann \lstinline|k_act| wie vorgesehenen mit den Parametern \lstinline|(indic, indic-1, indic+1)| berechnet werden.
	\ifimportant
	\lstinputlisting[firstnumber=28, style=intext, linerange={89,91,92,94}, caption={Ausschnitt 4 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A4.py}]{../Code/DCE/DCE.py}
	\fi
	Wenn die Sonderfälle behandelt und \lstinline|k_bef| und \lstinline|k_act| berechnet wurden, können beide Werte im \lstinline|sort_arr| aktualisiert werden. Dazu existiert die Funktion \lstinline|update_sort_arr_sec|. Danach folgt eine Abfrage, ob das Polygon bereits auf die geforderte Anzahl Punkte vereinfacht worden oder die Anzahl der Punkte im Polygon kleiner gleich 3 ist. In diesem Fall wird das Polygon in Pixelwerte, bzw. ein Array, umgewandelt und zurückgeben. Ansonsten beginnt die Schleife von vorne. \\
	Außerhalb der Schleife ist die gleiche Rückgabefunktion \lstinline|polygon_to_pixels| vorhanden, um in jedem Fall ein vereinfachtes Polygon zurückzugeben.
	\ifimportant
	\lstinputlisting[style=intext,linerange={153,160-169}, caption={Ausschnitt aus \protect\lstinline|calc_k_for_all_points| Funktion in DCE.py}, label = {cd:DCE_calc_k_for_all_points.py}]{../Code/DCE/DCE.py}
	
	\lstinputlisting[style=intext,linerange={99,110,112,113,115,116,117}, caption={Ausschnitt 1 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A1.py}]{../Code/DCE/DCE.py}
	\fi

	Es folgt eine Beschreibung der \lstinline|update_sort_array_sec| Methode, die dazu gedacht ist, das Array mit den Indexen und K-Werten um einen Punkt zu reduzieren und die benachbarten Punkte mit neuen K-Werten zu aktualisieren. \ifimportant Der folgende Text bezieht sich auf Listing \ref{cd:update_sort_arr_sec_A1.py}. \fi \\
	Wie auch im Polygon muss der Punkt mit dem geringsten K Wert im Array gelöscht werden. Dieser ist aufgrund der Sortierung des Arrays, das erste Tupel im Array. Nach diesem Schritt wird das Array sortiert und der neu berechnete K-Wert des aktuellen Punktes, der gerade entfernt wurde, an das Array angefügt. \\
	\ifimportant
	\lstinputlisting[firstnumber=8,style=intext,linerange={120,121,122,123,124,125}, caption={Ausschnitt 2 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A2.py}]{../Code/DCE/DCE.py}
	\fi Danach werden verschiedene Sonderfälle für das Einfügen des neuen K Wertes für den vorherigen Punkt behandelt \ifimportant (s. Listing \ref{cd:update_sort_arr_sec_A2.py} - \ref{cd:update_sort_arr_sec_A4.py})\fi. Wenn der \lstinline|k_act| der erste Punkt im Polygon ist, ist der vorherige Punkt für \lstinline|k_bef| der letzte Punkt im Polygon (\lstinline|NoP_Poly-1|). Sonst kann der vorherige Punkt wie vorgesehen im Array mit einer Numpy internen Funktion gesucht werden und an dem gefundenen Index wird der K-Wert aktualisiert. \\
	\ifimportant
	\lstinputlisting[firstnumber=14,style=intext,linerange={128,129,130,131,132,134,135,136,137,138}, caption={Ausschnitt 3 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A3.py}]{../Code/DCE/DCE.py}
	\fi In der nächsten IF Abfrage \ifimportant (s. Listing \ref{cd:update_sort_arr_sec_A3.py}) \fi wird der redundante Wert gelöscht, der durch das Hinzufügen der \lstinline|k_act| Variable entstanden ist. Dies ist der Index und der K-Wert des nachfolgenden Punktes (\lstinline|indic+1|). Hier wird ebenfalls zuerst der Sonderfall abgefangen, dass \lstinline|indic+1| der Gesamtpunktzahl im Polygon entspricht. Wenn dies feststeht, wird der letzte Wert des Arrays gelöscht, ansonsten muss der Wert im Array gesucht werden. Falls dieser Wert nicht gefunden wird, löscht das Programm wieder das letzte Tupel aus dem Array, sonst wird das gefundene Tupel an der Stelle gelöscht.
	\ifimportant
	\lstinputlisting[firstnumber=24,style=intext,linerange={140,141,142,143,145,146,147,148}, caption={Ausschnitt 4 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A4.py}]{../Code/DCE/DCE.py}
	\fi Durch diese Löschung muss der Index aller nachfolgenden Punkte um 1 verringert werden, damit die Punktindizes im Array mit den Punkten im Polygon übereinstimmen \ifimportant (s. Listing \ref{cd:update_sort_arr_sec_A4.py})\fi. Dies muss nur gemacht werden, wenn nicht das letzte Tupel im Array gelöscht wurde, und wird durch eine Schleife mit einer integrierten IF Abfrage implementiert. Diese IF Abfrage vergleicht den ersten Wert des Tupels (den Index) mit dem des gelöschten Tupel (an Stelle des Punktindizes) und verringert diesen um 1, wenn er größer ist.
	Im letzten Schritt wird das Array nochmals mit Quicksort sortiert und zurückgeben.
	
}


\subsection{Shape Similarity Measure (SSM)}{
	\label{py:Shape_Sim_Meas}
	Beide Versionen der YOLO Implementierung erzeugen ein mehrdimensionales Array, welches für jedes Frame jedes Polygon mit Gesamtwinkelsumme, ClassID und Umriss enthält. Dieses mehrdimensionale Array wird ausgewertet, um einzuschätzen, ob die DCE zum Objekttracking geeignet ist. Für weitere Erläuterungen bezüglich der Theorie s. Kap. \ref{theo:SSM}. \\
	\ifimportant
	\lstinputlisting[style=intext, linerange={29,37,38,40,45,46,47,48}, caption={Ausschnitt aus \protect\lstinline|calc_shape_similarity| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_main.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\fi

	Die Ergebnisse werden in einem weiteren Dictionary (\lstinline|result_dictionary|) gespeichert, welches als letzten Schritt in eine Textdatei geschrieben wird, um alle Ergebnisse und Einstellungen zentral zu speichern. \ifimportant In Listing \ref{cd:SSM_main.py} ist zu sehen, in welcher Reihenfolge das \lstinline|result_dictionary| mit Elementen gefüllt wird. \fi Die ersten Zeilen des Dictionary bestehen immer aus einer Zeitangabe, wann das Programm abgeschlossen wurde und Daten zu den Polygonen und Winkeln. Hier werden für jeden Testfall die Anzahl der verglichenen Polygone und die Gesamtanzahl dieser gespeichert. Außerdem wird die Zahl der verglichenen Winkel und die Punktanzahl der Polygone vor und nach der Vereinfachung durch DCE aufgelistet. \\
	Wenn die ersten Zeilen im Dictionary geschrieben wurden, wird das Formähnlichkeitsmaß, im folgenden auch als \glqq Shape Similarity Measure\grqq{} (SSM) bezeichnet, berechnet. Nach diesem Schritt werden die Zeitstempel kalkuliert und in das \lstinline|result_dictionary| geschrieben, sowie die Programmeinstellungen im Dictionary gespeichert. Der letzte Schritt besteht daraus, dass \lstinline|result_dictionary| als Textdatei an dem entsprechend festgelegten Pfad zu speichern. \\
	\ifimportant
	\lstinputlisting[style=intext, linerange={53,62,63,83,85,86,87,88,89,90,91}, caption={Ausschnitt 1 aus \protect\lstinline|calc_SSM_illustration| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_illu_A1.py}]{../Code/Shape_Similiarity/shape_sim_meas.py} 
	\fi

	Die \lstinline|calc_SSM_illustration| Funktion, die das Formähnlichkeitsmaß berechnet, läuft folgendermaßen ab\ifimportant \ (s. Listing \ref{cd:SSM_illu_A1.py})\fi. Nachdem aus dem \lstinline|options| Dictionary die Liste aller Polygone in eine neue Variable gespeichert wurde, kann über diese Variable iteriert werden. Hierfür wird die Anzahl der Frames, bzw. die Länge des Arrays, genutzt, da mit jedem Frame alle Polygone, die in diesem detektiert wurden, verknüpft sind. \\
	In der FOR Schleife wird zunächst mit einer IF Abfrage eine Variable (\lstinline|compare_polys|) mit der geringeren Polygonanzahl zum nächsten Frame initialisiert. Dies ist wichtig, da das Frame mit der geringeren Polygonanzahl die Berechnung des Formähnlichkeitsmaßes limitiert, um nur Polygone zu vergleichen, die auch im nächsten Frame noch vorhanden sind. In dieser IF Abfrage wird auch eine Zählvariable erhöht, die die Zahl der verglichenen Polygone speichert. \\
	\ifimportant
	\lstinputlisting[firstnumber=12,style=intext, linerange={93,95,96,67,98,99,100,101,112,113,114,115,116}, caption={Ausschnitt 2 aus \protect\lstinline|calc_SSM_illustration| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_illu_A2.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\fi Im nächsten Schritt wird über alle Polygone des jeweiligen Frames mit einer weiteren FOR Schleife iteriert\ifimportant \ (s. Listing \ref{cd:SSM_illu_A2.py})\fi. Da nur Polygone verglichen werden dürfen, deren detektierte Klasse die gleiche ist, ist in dieser Schleife ein MATCH CASE Fall vorhanden. Hier wird nach den drei Hauptklassen und \lstinline|other_Object|, bzw. anderen Klassen, unterschieden. Wenn im aktuellen und im nächsten Frame die gleichen Klassen bei dem gleichen Polygon erkannt wurden, kann die geringste SSM mit der Methode \lstinline|calc_minor_SSM| berechnet werden. Dieser Rückgabewert wird dann dem Array übergeben, welches alle Werte speichert. Bei allen drei Hauptklassen geschieht dies ähnlich. Wenn jedoch eine andere Klasse erkannt wurde, wird dem entsprechenden Array die ClassID und der geringste SSM als Tupel hinzugefügt. \\
	\ifimportant
	\lstinputlisting[firstnumber=25,style=intext, linerange={118,119,120,122,124,125,126,127,128,130,131,135}, caption={Ausschnitt 3 aus \protect\lstinline|calc_SSM_illustration| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_illu_A3.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\fi Damit sind die beiden ineinander verschachtelten FOR Schleifen durchlaufen und die Anzahl der detektierten Objekte für jede Hauptklasse kann an der Länge der Arrays mit den SSM Werten gespeichert werden\ifimportant \ (s. Listing \ref{cd:SSM_illu_A3.py})\fi. Dies ist der Fall, weil für jedes detektierte Objekt der Klassen exakt ein Element in das Array gespeichert wurde, welches die geringste Abweichung besitzt. Für das Array, welches die Tupel mit allen weiteren Objekten enthält, wird eine Methode aufgerufen, die von Bucketsort inspiriert wurde, in welcher alle Elemente nach der jeweiligen Klasse sortiert und in Teilen summiert werden \ifimportant (s. Listing \ref{cd:SSM_sort_oO_arr.py})\fi.  \\
	Im nächsten Schritt werden die berechneten Werte in das \lstinline|result_dictionary| gespeichert. Dies geschieht alle Objekte, die nicht den Hauptklassen entsprechen, mit einer FOR Schleife, damit die Ausgabe dynamisch an alle erkannten Klassen angepasst werden kann. Damit ist diese Funktion abgeschlossen. \\
	\ifimportant
	\lstinputlisting[style=intext, linerange={230,238-248,255}, caption={Ausschnitt aus \protect\lstinline|calc_minor_SSM| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_calc_minor_SSM.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\fi

	Die Funktion \lstinline|calc_minor_SSM| \ifimportant (s. Listing \ref{cd:SSM_calc_minor_SSM.py}) \fi arbeitet mit zwei Arrays, die die jeweiligen Winkelindizes und Winkel für jeden Punkt für jeweils ein Polygon enthalten. Es wird zunächst ein Array initialisiert, indem alle berechneten SSMs gespeichert werden. Danach wird eine FOR Schleife genutzt um alle Permutationen für den Vergleich der beiden Arrays zu durchlaufen. In dieser Schleife ist eine IF Abfrage vorhanden, um zu verhindern, dass ein Array keine Werte zum Vergleich enthält (bzw. die Länge 0 hat). Wenn kein Array die Länge 0 besitzt, kann die \lstinline|compare_arrays| Methode gestartet werden, die alle Elemente des ersten Arrays von allen Elementen des zweiten Arrays an der gleichen Stelle subtrahiert. Diese SSM wird dann dem Array hinzugefügt und das zweite Polygon wird um ein Element verschoben. Bei dem zweiten Array wird das unterste Element zum ersten Element kopiert, sodass das Array permutiert. Diese Schritte wiederholen sich, bis das zweite Array einmal vollständig permutiert wurde. Danach wird aus dem \lstinline|SSM_arr| Array der geringste Wert und der Index von diesem Wert mit NumPy internen Funktionen gesucht und als Array zurückgegeben. \\
	\ifimportant
	\lstinputlisting[style=intext, linerange={260,269-278,280,282-284,286,291,298-302}, caption={Ausschnitte aus \protect\lstinline|compare_arrays| und \protect\lstinline|permute_arr| Funktionen in shape\_sim\_meas.py}, label = {cd:SSM_compare_and_permute_arr.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\fi

	In der Funktion \lstinline|compare_arr| \ifimportant (s. Listing \ref{cd:SSM_compare_and_permute_arr.py}) \fi wird zunächst eine Variable gespeichert, die die Länge des kürzesten Arrays von beiden besitzt. Anhand dieser wird die folgende FOR Schleife limitiert, damit nur Werte verglichen werden, für die auch ein Gegenstück vorhanden ist.
	In der FOR Schleife wird ein Variable erhöht, indem immer der Absolutbetrag der Differenzen zwischen dem ersten Array an der entsprechenden Stelle und dem zweiten Array an der gleichen Stelle addiert wird. Dieser Absolutbetrag sorgt dafür, dass die Variable gegen 0 geht und das Formähnlichkeitsmaß eine höhere Ähnlichkeit durch einen geringeren Wert repräsentiert. Danach wird die Variable zur weiteren Verarbeitung zurückgeben. \\
	\ifimportant
	\lstinputlisting[style=intext, linerange={200,209-212,214-217,219-223,225}, caption={Ausschnitt aus \protect\lstinline|sort_oO_arr_new| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_sort_oO_arr.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\fi

	Die \lstinline|sort_oO_arr_new| Funktion, welche das Array mit den SSM Werten für alle anderen Objekte sortiert,  läuft folgendermaßen ab. Zuerst wird eine FOR Schleife gestartet, in der eine IF Abfrage überprüft, ob ein Behälter (im folgenden \glqq Bucket\grqq{} genannt) im \lstinline|buckets| Array existiert. Die Schleife iteriert über alle Elemente im  \lstinline|val_arr_oO| Array. Wenn in diesem \lstinline|buckets| Array der Behälter nicht existiert wird er hinzugefügt. \\
	Wenn diese erste FOR Schleife durchlaufen ist, wird eine zweite FOR Schleife (die über Elemente in \lstinline|val_arr_oO| Array iteriert) gestartet, die verschachtelt ist mit einer dritten FOR Schleife (die über alle Elemente im \lstinline|buckets| Array iteriert), um alle Objekte im \lstinline|val_arr_oO| Array dem entsprechenden Bucket im \lstinline|buckets| Array zuzuordnen. \\
	Mit dem Abschluss der zweiten und dritten FOR Schleife, sind alle Elemente aus dem \lstinline|sort_arr_oO| Array einem Bucket zugeordnet und müssen aufsummiert werden. Dies geschieht mit einer vierten FOR Schleife, die über das \lstinline|buckets| Array iteriert. Dort wird das erste Element, welches die ClassID repräsentiert, temporär gespeichert und die restlichen Werte an der Stelle im Array aufsummiert. Im letzten Schritt in der Schleife wird das \lstinline|buckets| Array an der jeweiligen Stelle überschrieben, damit das Array nur 3 Werte pro Element enthält. \\ 
	Nun sind alle FOR Schleifen durchlaufen und das \lstinline|buckets| Array kann zurückgeben werden. \\

	Damit sind alle relevanten Funktionen zur Durchführung der Berechnung des Formähnlichkeitsmaßes beschrieben und das Programm ist nach der Ausgabe des generierten Videos und der Statistikdatei vollständig abgeschlossen.

}







