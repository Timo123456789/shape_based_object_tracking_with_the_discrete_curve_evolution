%!TEX root = ../thesis.tex
\chapter{Implementierung (LISTINGS ÜBERPRÜFEN)} 
\label{ch:implementierung}


%\section{Implementierung in Python}
{\label{implementation_in_python}} 
Im Folgenden wird die Implementierung anhand von Codebeispielen erläutert. Die angegebenen Listings sind zum einfachen Verständnis gekürzt und ohne Kommentare. Für ein Listing des gesamten Codes mit Kommentaren siehe Anhang \ref{cd:gesamt_listing}. \\ \todo{vielleicht bei Textbeschreibung auf klare Codezeilen in Listings beziehen? siehe  Zeile 3 in Ls 5.14 etc.}
EF Version ist die Abkürzung für \glqq Every Frame\grqq{} Version (1. YOLO Variante) und RV Version ist die Abkürzung für \glqq Result\grqq{} Version (2. YOLO Variante), die direkt mit einem von YOLO generierten Objekt arbeitet. 
\section{Main File}
{ \todo{main.py und shape\_sim\_meas Listings überprüfen!!!!}
	Das Main File importiert alle Unterskripte, da es auf die Funktionen zugreifen muss, um das Video zu verarbeiten und zu schreiben. Diese Unterskripte sind: 
	\begin{itemize}
		\item yolo\_every\_frame (siehe \ref{py:YOLO_every_frame})
		\item yolo\_result\_version (siehe \ref{py:YOLO_res_vers})
		\item DCE.py (siehe \ref{py:DCE})
		\item shape\_sim\_meas.py (siehe \ref{py:Shape_Sim_Meas})
	\end{itemize}
	Dazu wird die Erweiterung CV2 (siehe \ref{subsec:Computer_Vision_2}) eingelesen, um das Video aus einzelnen Frames zu generieren.\\
	Die Main Methode besteht aus einer Dictionary Variable \lstinline|options|, in der alle Einstellungen für die Verarbeitung des Videos gesetzt werden. Hier werden auch die einzelnen Zeitstempel gespeichert. Ein Ausschnitt ist in Listing \ref{cd:part_of_options_var} zu sehen. \\
	In diesem werden die Lese- und Schreibpfade für das Quell- und Ergebnisvideo festgelegt, sowie der Pfad für die Textdatei, die die Timestamps enthält. In den nächsten Zeilen kann festgelegt werden, auf bis viele Punkte die von YOLO detektierten Objekte reduziert werden. Diese werden in 4 unterschiedliche Objekttypen unterteilt: Auto (Car), Motorrad (Motorcycle), LKW (Truck) und andere Objekte (other\_Object). \\
	Des Weiteren wird das genutzte YOLO Modell definiert und festgelegt, ob nur die vereinfachten Umrisse der erkannten Objekte ausgegeben werden. Des Weiteren kann gesteuert werden, ob die von YOLO detektierten Objektboundingboxen schwarz ausgefüllt werden, sodass der Umriss klarer erkannt wird. Hier kann auch die Ausgabe der Labels gesteuert werden, diese beinhalten die Information, was für eine Klasse, bzw. Objekt, detektiert wurde und wie hoch der Confidence Score ist. \\
	Standardmäßig ist die Version des Codes ausgewählt, die das Video erst vollständig von YOLO analysieren lässt, dies lässt sich mit der \lstinline|yolo_every_frame| Boolean umstellen. Die letzte Boolean beschreibt, ob Zeitstempel gesetzt werden sollen. Dieses Dictionary hat noch weitere Einträge, die der Verwaltung der verschiedenen Zeitstempel und weiterer Messwerte dienen. \\
	\lstinputlisting[style=intext, linerange={338,339-342,344-346,348-351,353-357,359}, caption={Ausschnitt aus der \protect\lstinline|options| Variable in  Main.py}, label = {cd:part_of_options_var}]{../Code/main.py}
	\todo{Listing ist eigentlich überflüssig?}
	Im weiteren Verlauf wird dann ausgewählte Version des Codes gestartet und beim Abschluss das Video und die Textdatei in die entsprechenden Pfade geschrieben.
	Es existieren außerdem Funktionen, um die Testfälle zur Evaluation mit einem Programmdurchlauf zu generieren und die \lstinline|options| Variable wieder auf ihre Standardwerte zurückzusetzen. Dies ist erforderlich um für Testfälle andere Einstellungen festlegen zu können.
}



\section{1. YOLO Variante (EF Version)} {
	\label{py:YOLO_every_frame}
	In dieser Variante wird das Video in einzelne Frames mit CV2 zerlegt, auf die dann jeweils der ausgewählte YOLO Algorithmus angewendet wird. Der Fortschrittsbalken bildet anhand der durchlaufenden Frames den Berechnungsfortschritt ab. 
	Es wird über alle Frames des Videos iteriert, in der das jeweilige Frame aus dem Video extrahiert wird und dann an die Methode übergeben wird, die YOLO anwendet. \todo{Linienbrechung Listings nachschauen}
	\lstinputlisting[style=intext,linerange={41,43,45,46,48,50,56}, caption={Ausschnitt aus yolo\_every\_frame.py}, label = {cd:part_of_yolo_every_frame.py}]{../Code/YOLO/yolo_every_frame.py}
	Dies geschieht indem zuerst die Gesamtanzahl der Frames in der \lstinline|framecounter| Variablen gespeichert wird, welche den Iterator für die Schleife limitiert (siehe Listing \ref{cd:part_of_yolo_every_frame.py}). \\ 
	In der Schleife wird das jeweilige Frame an der \lstinline|i|-ten Stelle als Bilddatei in der \lstinline|img| Variablen gespeichert. Dieses wird dann im nächsten Schritt der Funktion übergeben, die das Bild mit YOLO analysiert und zurückgibt. Ein vorher festgelegtes Array speichert dann alle analysierten Bilder. \\ 
	Wenn die Schleife terminiert, wird das Array aus Bildern zu einem Video zusammengesetzt und gespeichert. \\

	
	\lstinputlisting[style=intext,linerange={66,77,84,96,98,103,104,106,115,116,118,119,127-129,131,132}, caption={Ausschnitt aus der \protect\lstinline|run_yolo| Funktion in yolo\_every\_frame.py}, label = {cd:run_yolo_func_in_yolo_every_frame.py}]{../Code/YOLO/yolo_every_frame.py}
	
	Ausschnitte der \lstinline|run_yolo| Funktion sind in Listing \ref{cd:run_yolo_func_in_yolo_every_frame.py} zu sehen. Zuerst wird hier das YOLO Modell festgelegt. Danach wird der Frame von YOLO analysiert, welches in der yolo\_segmentation.py erfolgt. Hier wird ein Objekt zurückgeben, welches die Boundingboxen der detektierten Objekte, die jeweiligen Klassen, die segmentierten Umrisse und den jeweiligen Confidence Score enthält. \\
	Dieses Objekt wird in der darauffolgenden Schleife durchlaufen. Hier werden zunächst die Koordinaten der jeweiligen Boundingbox gesetzt und im nächsten Schritt werden die Umrisse mit der DCE vereinfacht (für eine genauere Beschreibung in der Theorie siehe Kap. \ref{sec:Discrete Curve Evolution} und im Code siehe Kap. \ref{py:DCE}). 
	Zuvor wird noch die Variable abgefragt, ob die Boundingboxen der erkannten Objekte mit schwarzen Pixeln gefüllt werden sollen. Mit CV2 werden danach die Boundingboxen und die Umrisse der Polygone gezeichnet. Für den Fall, dass die \lstinline|write_Labels| Variable im \lstinline|options| Dictionary auf True gesetzt ist, werden im nächsten Schritt der Confidence Score und die Class ID an die Boundingbox geschrieben. \\
	Zur Evaluation werden im nächsten Schritt die Winkelsummen für jedes Polygon summiert und in einem Array im \lstinline|options| Dictionary gespeichert. \\
	Wenn alle Frames des Videos durchlaufen wurden, werden die einzelnen Frames wieder zu einem Video zusammengesetzt und statistische Auswertungen (siehe Kap. \ref{py:Shape_Sim_Meas}) durchgeführt. Damit ist dieser Abschnitt des Programmes abgeschlossen.

	\lstinputlisting[style=intext,linerange={31,37,46-48,59,61-64,68,70,72,73}, caption={Ausschnitt aus  yolo\_segementation.py}, label = {cd:yolo_in_yolo_segmentation.py}]{../Code/YOLO/yolo_segmentation.py}
	\todo{Listing ist eigentlich überflüssig?}

	YOLO\_segmenation.py basiert auf einer Entwicklung von \citeauthor{Canu_pysource} \citep{Canu_pysource} und beinhaltet einige Abänderungen. Der Code auf den sich im Folgenden bezogen wird, ist in Listing \ref{cd:yolo_in_yolo_segmentation.py} zu sehen. Hier wird nach der Initialisierung des YOLO Modells die Detektionsfunktion ausgeführt. Diese beinhaltet die Prediction und eine IF Abfrage, wenn keine Objekte von YOLO erkannt wurden. Wenn Objekte erkannt wurden, werden deren Boundingboxen, ClassIDs, Umrisse und Confidence Scores zurückgeben. 
	}

\section{2. YOLO Variante (RV Version)}{
	\label{py:YOLO_res_vers}
	Diese Variante des Codes analysiert das Video direkt am Anfang mit YOLO. Dies bietet den Vorteil, dass durch die effiziente Implementierung von YOLO die Gesamtdauer des Programmes verringert wird. Der Fortschrittsbalken bildet bei dieser Implementierung anhand der von der DCE durchlaufenen Polygone den Berechnungsfortschritt ab.  Die Anwendung von YOLO findet direkt in main.py statt. Dies ist in Listing \ref{cd:yolo_result_main.py} zu sehen.

	\lstinputlisting[style=intext,linerange={109,115,117,121,125,128,130}, caption={Ausschnitt aus \protect\lstinline|run_yolo_result_version| in main.py}, label = {cd:yolo_result_main.py}]{../Code/main.py}
	\todo{Listing ist eigentlich überflüssig?}

	Da hier das gesamte Video in dem von YOLO generierten \lstinline|results| Objekt gespeichert wird, benötigt die Funktion, die das Video verändert nur dieses Objekt und das \lstinline|options| Dictionary. \\
	

	Die \lstinline|get_outline_for_every_object| Funktion (siehe Listing \ref{cd:yolo_result_get_outline_for_every_object.py}) läuft folgendermaßen ab. \\
	Die Schleife iteriert über die Gesamtanzahl der Frames im Video. Durch die IF Abfrage wird der Fall abgefangen, dass kein Objekt im Frame erkannt wurde. Wenn ein Objekt erkannt wurde, werden mit der \lstinline|get_data| Funktion die Daten der detektierten Objekte aus dem Frame exportiert. Ansonsten wird das Frame ohne Veränderung überschrieben, wenn das Video im \lstinline|options| Dictionary nicht auf schwarz gesetzt wurde. Die \lstinline|get_data| Funktion basiert auf \citeauthor{Canu_pysource} \citep{Canu_pysource} und ist ähnlich zu der in Kap. \ref{py:YOLO_every_frame} (s. Listing \ref{cd:yolo_in_yolo_segmentation.py}) aufgebaut. \\
	Diese Daten werden in einzelne Variablen abgespeichert. Danach wird auf die Umrisse die DCE (siehe Kap. \ref{py:DCE}) angewendet. Mit CV2 werden die vereinfachten Umrisse dann in das Frame gespeichert, indem das gerade analysierte Frame überschrieben wird. Im weiteren Verlauf wird dann das Frame, bzw. je nach Einstellung nur die Boundingboxen der detektierten Objekte, mit schwarzen Pixeln ausgefüllt. \\
	\lstinputlisting[style=intext,linerange={31,38-40, 43-45,47-50,52-53,56,62,64-68}, caption={Ausschnitt 1 aus \protect\lstinline|get_outline_for_every_object| Funktion in yolo\_result\_version.py}, label = {cd:yolo_result_get_outline_for_every_object.py}]{../Code/YOLO/yolo_result_version.py}
	Die zweite FOR Schleife (siehe Listing \ref{cd:yolo_result_get_outline_for_every_object_second.py}) zeichnet für jedes erkannte Objekt im Frame die Boundingbox und die Labels, falls dies im \lstinline|options| Dictionary gesetzt wurde. Außerdem wird noch die Gesamtsumme der Winkel  zur späteren statistischen Auswertung für jedes Polygon berechnet.
	\lstinputlisting[style=intext,firstnumber = 21,linerange={70,71,72,74,76,77,80,93,95,96,98,99,102}, caption={Ausschnitt 2 aus \protect\lstinline|get_outline_for_every_object| Funktion in yolo\_result\_version.py}, label = {cd:yolo_result_get_outline_for_every_object_second.py}]{../Code/YOLO/yolo_result_version.py}
	Wenn die Schleifen durchgelaufen sind, wird das veränderte \lstinline|result| Objekt und das \lstinline|options| Dictionary zurückgeben. Danach wird das Video an dem angegebenen Pfad gespeichert. Es werden statistische Auswertungen (siehe Kap. \ref{py:Shape_Sim_Meas}) durchgeführt und die Timestamps gespeichert. Damit ist dieser Teil des  Programmes abgeschlossen. \\
	}

\section{Discrete Curve Evolution}{
	\label{py:DCE}
	\todo{dce listings checken}
	Die folgende Implementierung basiert auf \citeauthor{Barkowsky2000} \citep{Barkowsky2000} (siehe Kap. \ref{sec:Discrete Curve Evolution}). Die DCE wird durch ähnlich implementierte Funktionen in beiden YOLO Implementierungen gestartet. Als Beispiel wird hier die Implementierung aus yolo\_result\_version.py genutzt. Diese ist in Listing \ref{cd:yolo_result_run_DCE.py} zu sehen. \\

	\lstinputlisting[style=intext,linerange={107,116-126}, caption={Ausschnitt aus \protect\lstinline|run_DCE| Funktion in yolo\_result\_version.py}, label = {cd:yolo_result_run_DCE.py}]{../Code/YOLO/yolo_result_version.py}
	\todo{Listing ist eigentlich überflüssig?}
	Hier wird anhand der erkannten Klassen Auto, Motorrad und LKW die Methode zur Polygonvereinfachung mit einer festen Punktgrenze ausgeführt. Dies passiert auch, falls das detektierte Objekt nicht zu diesen drei Klassen gehört. \\ 
	Zurückgegeben wird ein Array, welches die vereinfachten Umrisse von jedem Objekt enthält, da das Ursprungspolygon immer mit dem vereinfachten Polygon überschrieben wird. \todo{klare Benennung! entweder Umriss, oder Polygon}\\

	\subsection{Implementierung der K Wert Berechnung \label{impl:Calc_K_Val}} 

	Der K Wert wird in der folgenden Funktion \lstinline|calc_k_with_points| berechnet. Diese Methode basiert auf der Formel \ref{Equ_K_Bark} ( nach \citet{Latecki1999a}) und ist dahingehend abgeändert worden, dass diese nicht mit Liniensegmenten, sondern mit drei Punkten berechnet werden kann. Die abgeänderte Formel lautet:
	\begin{equation}
		K(p,S_1,S_2) = \frac{\beta(p, S_1, S_2)l(p, S_1)l(p, S_2)}{l(p, S_1) + l(p, S_2)} 
		\label{equ_K_DCE_points}
	\end{equation}
	Im Programmcode ist dies folgendermaßen implementiert (siehe Listing \ref{cd:DCE_calc_k_with_points.py}). Als Eingabe wird das Polygon, der betrachtete Punkt (\lstinline|p|), der folgende (\lstinline|s1|) und der vorherige (\lstinline|s2|) Punkt erwartet. Die Reihenfolge von betrachteter, folgender und vorheriger Punkt bei der Parameterübergabe kann aufgrund von Sonderfallbehandlung in den Beschreibungen in Kap. \ref{impl:DCE_SimplyfierFunc} abweichen. \\ 
	Es wird zunächst der Winkel $\beta$ berechnet, indem alle drei Punkte und das Polygon übergeben werden. Danach werden die beiden Distanzen zwischen $p, S_1$ und $p, S_2$ berechnet. Die Winkelberechnungsfunktion arbeitet mit NumPy und die Distanzberechnungsfunktion basiert auf Funktionen, die GeoPandas bietet.
	\lstinputlisting[style=intext,linerange={203,217-219,221,222}, caption={Ausschnitt aus \protect\lstinline|calc_k_with_points| Funktion in DCE.py}, label = {cd:DCE_calc_k_with_points.py}]{../Code/DCE/DCE.py}
	Diese drei Werte werden dann analog zur Formel \ref{equ_K_DCE_points} zum Wert K berechnet. Als letzten Schritt wird dieser Wert und der Winkel als Array zurückgegeben.
	
	In Listing \ref{cd:DCE_angle_and_distance.py} ist zu sehen, dass die Winkelberechnungsfunktion mit dem Arcustangens und $\pi$ arbeitet. Dies basiert auf der Dokumentation von NumPy \citep{numpy_angle}. Da die Berechnung ein Array ausgibt, müssen alle Elemente aufsummiert werden, um einen Wert zu erhalten. Dieser Wert wird dann in Radiant umgerechnet und zurückgeben. \\
	Die Distanzberechnung erfolgt mit einer Funktion, die GeoPandas bei \lstinline|Geopanda.Geoseries| Objekt bietet. Diese errechnet die Distanz zwischen den Punkten \lstinline|p1| und \lstinline|p2|. Danach wird diese zurückgegeben.

	\lstinputlisting[style=intext,linerange={325,337-339,349,350,352,353,357,374,383-386}, caption={Ausschnitte aus \protect\lstinline|get_angle_two_lines| und \protect\lstinline|get_distance_between_two_points| Funktionen in DCE.py}, label = {cd:DCE_angle_and_distance.py}]{../Code/DCE/DCE.py}
	\todo{Listing ist eigentlich überflüssig?}

	\subsection{Implementierung der Vereinfachungsfunktion \label{impl:DCE_SimplyfierFunc}}

	

	Nun wird der Prozess innerhalb der DCE.py Datei genauer erläutert (siehe Listing \ref{cd:DCE_simplify_polygon_A1.py} - \ref{cd:DCE_simplify_polygon_A4.py}). Es ist zu beachten, dass die Berechnungsfunktion nur mit den Indizes für die Punkte des Polygons arbeiten, sodass die Punkte nicht direkt angesteuert werden können. Da die DCE in dieser Arbeit mit GeoPandas (siehe Kap. \ref{subsec:Geopandas}) implementiert wurde, muss das Array zuerst in ein \lstinline|Geopandas.Geoseries| Objekt transformiert werden. \\
	Danach kann von diesem Polygon die Gesamtpunktanzahl berechnet werden und der Fall abgefangen werden, dass ein Polygon bereits weniger Punkte als die Punktanzahl, auf die das Polygon reduziert werden soll, hat. \\

	\lstinputlisting[style=intext,linerange={47,56-57,59-63}, caption={Ausschnitt 1 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A1.py}]{../Code/DCE/DCE.py}

	
	Es folgt die Berechnung der K Werte für alle Punkte (s. Listing \ref{cd:DCE_calc_k_for_all_points.py}), indem das Polygon einmal vollständig durchlaufen wird. Diese werden in einem zweidimensionalen Array gespeichert. Danach wird dieses Array in ein Numpy Array umgewandelt, damit die Funktionen der Bibliothek auf dieses angewendet werden können. Als nächsten Schritt wird dieses Array nach dem zweiten Index, dem K-Wert für jeden Punkt, sortiert, sodass der Index mit dem geringsten K-Wert an der ersten Stelle des Arrays steht. Hierzu wird das Quicksort-Verfahren (s. Kap. \ref{subsec:NumPy}), welches Numpy bereits integriert hat, genutzt. \\

	\lstinputlisting[style=intext,firstnumber=9, linerange={65,66,68,69,71,72,73,74}, caption={Ausschnitt 2 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A2.py}]{../Code/DCE/DCE.py}


	Im weiteren Verlauf folgt eine While Schleife (siehe Listing \ref{cd:DCE_simplify_polygon_A1.py}) in der zuerst der Index des Punktes mit dem geringsten K abgespeichert wird. Anhand dieses Indexes können nun die neuen K-Werte nach einer Entfernung dieses Punktes berechnet werden. Dieser Punkt wird nun im weiteren Verlauf aus dem Polygon entfernt, sodass im weiteren Verlauf die neuen K-Werte berechnet werden können. Es wird nun die neue verringerte Punktzahl des Polygons abgespeichert. \\
	Nun werden verschiedene Sonderfälle zur Berechnung erklärt. Der erste Sonderfall ist, dass \lstinline|indic| dem Wert 0 entspricht. Daraus kann der vorherige K-Wert \lstinline|k_bef| berechnet werden, indem als betrachteter Punkt der letzte Punkt des Polygons (Index: \lstinline|NoP_temp-1|) mit den Nachbarpunkten (als Index) \lstinline|0|  als folgender Punkt und \lstinline|NoP-2| als vorherigen Punkt der Berechungsfunktion übergeben wird. \\
	Bei der Berechnung des K-Wertes für den aktuellen Punkt \lstinline|k_act| muss als Parameter der erste Punkt des Polygons (Index: 0), der vorherige Punkt (\lstinline|NoP-1|) und \lstinline|1| als folgenden Punkt der Funktion \lstinline|calc_k_with_points| (s. Kap. \ref{impl:Calc_K_Val}) übergeben werden. \\

	\lstinputlisting[firstnumber=17, style=intext, linerange={76,77,78,79,80,81,82,84,85,86,87}, caption={Ausschnitt 3 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A3.py}]{../Code/DCE/DCE.py}

	Wenn \lstinline|indic| nicht dem Wert 0 entspricht, wird wie in Listing \ref{cd:DCE_simplify_polygon_A3.py} verfahren. Dieses Listing wird nun näher erläutert.
	Es wird zunächst der Fall behandelt, dass \lstinline|indic-1| dem Wert 0 entspricht. Wenn dies der Fall ist, muss Berechnung von \lstinline|k_bef| angepasst werden, indem als für die Übergabeparameter der K-Wert Berechnung, der erste Punkt des Polygons (\lstinline|0|), der folgende Punkt (\lstinline|1|) an zweiter Stelle und der letzte Punkt des Polygons (\lstinline|NoP-1|) an dritter Stelle übergeben werden. \\
	Im ELSE Teil dieser Abfrage werden weitere IF Abfragen genutzt um den Fall abzufangen, dass \lstinline|indic+1| größer ist als das Polygon Punkte hat, nachdem der Punkt mit dem geringsten K Wert entfernt wurde. In diesem Fall wird \lstinline|k_bef| so berechnet, dass der vorherige Punkt (\lstinline|indic-1|) von \lstinline|indic| mit den Übergabeparameter \lstinline|0| als folgenden und \lstinline|indic| als vorherigen Punkt berechnet wird. Wenn dies nicht der Fall ist, kann \lstinline|k_bef| auf dem vorgesehenen Weg mit den Übergabeparameter \lstinline|(indic-1, indic, indic-2)| berechnet werden. \\

	Nun wird der Sonderfall behandelt, dass \lstinline|indic+1| größer als die Anzahl der Punkte im Polygon nach dem Entfernen des Punktes mit dem geringsten K Wert ist, um \lstinline|k_act| zu berechnen. Diese Variable speichert den aktuellen neuen K-Wert des vorher entfernten Punktes. \\
	Wenn \lstinline|indic+1| größer ist, als die aktuelle Anzahl der Punkte im Polygon, muss die Berechnung dahingehend abgeändert werden, dass als aktueller betrachteter Punkt der K Berechnungsfunktion \lstinline|indic-1| übergeben wird, mit dem ersten Punkt (\lstinline|0|) des Polygons als ersten Nachbarn und dem vorherigen Punkt (\lstinline|indic-2|) als zweiten Nachbarn. Sollte \lstinline|indic+1| nicht größer als die aktuelle Anzahl der Punkte im Polygon sein, kann \lstinline|k_act| wie vorgesehenen berechnet werden mit den Parametern \lstinline|(indic, indic-1, indic+1)|.

	\lstinputlisting[firstnumber=28, style=intext, linerange={89,91,92,94}, caption={Ausschnitt 4 aus \protect\lstinline|simplify_polygon_fast_sec| Funktion in DCE.py}, label = {cd:DCE_simplify_polygon_A4.py}]{../Code/DCE/DCE.py}

	Wenn die Sonderfälle behandelt und \lstinline|k_bef| und \lstinline|k_act| berechnet wurden, können beide Werte im \lstinline|sort_arr| aktualisiert werden. Dazu existiert die Funktion \lstinline|update_sort_arr_sec|. Danach folgt eine Abfrage, ob das Polygon bereits auf die geforderte Anzahl Punkte vereinfacht worden ist. In diesem Fall wird das Polygon in Pixelwerte, bzw. ein Array, umgewandelt und zurückgeben. Ansonsten beginnt die Schleife von vorne. \\
	Außerhalb der Schleife ist die gleiche Rückgabefunktion \lstinline|polygon_to_pixels| vorhanden, um in jedem Fall ein vereinfachtes Polygon zurückzugeben.


	\lstinputlisting[style=intext,linerange={153,160-169}, caption={Ausschnitt aus \protect\lstinline|calc_k_for_all_points| Funktion in DCE.py}, label = {cd:DCE_calc_k_for_all_points.py}]{../Code/DCE/DCE.py}
	\todo{eigentlich auch überflüssiges Listing}

	Es folgt eine Beschreibung der \lstinline|update_sort_array_sec| Methode, die dazu gedacht ist, das Array mit den Indexen und K-Werten um einen Punkt zu reduzieren und die benachbarten Punkte mit neuen K-Werten zu aktualisieren. \\
	Wie auch im Polygon muss der Punkt mit dem geringsten K Wert im Array gelöscht werden. Dieser ist aufgrund der Sortierung des Arrays, das erste Tupel im Array. Nach diesem Schritt wird das Array sortiert und der neu berechnete K-Wert des aktuellen Punktes, der gerade entfernt wurde, an das Array angefügt. \\
	Danach werden verschiedene Sonderfälle für das Einfügen des neuen K Wertes für den vorherigen Punkt behandelt. Wenn der \lstinline|k_act| der erste Punkt im Polygon ist, ist der vorherige Punkt für \lstinline|k_bef| der letzte Punkt im Polygon (\lstinline|NoP_Poly-1|). Sonst kann der vorherige Punkt wie vorgesehen im Array mit einer Numpy internen Funktion gesucht werden und an dem gefundenen Index wird der K-Wert aktualisiert. \\
	In der nächsten IF Abfrage  wird der redundante Wert gelöscht, der durch das Hinzufügen der \lstinline|k_act| Variable entstanden ist. Dies ist der Index und der K-Wert des nachfolgenden Punktes (\lstinline|indic+1|). Hier wird ebenfalls zuerst der Sonderfall abgefangen, dass \lstinline|indic+1| der Gesamtpunktzahl im Polygon entspricht. Wenn dies feststeht, wird der letzte Wert des Arrays gelöscht, ansonsten muss der Wert im Array gesucht werden. Falls dieser Wert nicht gefunden wird, löscht das Programm wieder das letzte Tupel aus dem Array, sonst wird an das gefundene Tupel an der Stelle gelöscht. Durch diese Löschung muss der Index aller nachfolgenden Punkte um 1 verringert werden, damit die Punktindexe im Array mit den Punkten im Polygon übereinstimmen. Dies muss nur gemacht werden, wenn nicht das letzte Tupel im Array gelöscht wurde, und wird durch eine Schleife mit einer integrierten IF Abfrage implementiert. Diese IF Abfrage vergleicht den ersten Wert des Tupels (den Index) mit dem des gelöschten Tupel (an Stelle des Punktindizes) und verringert diesen um 1, wenn er größer ist.
	Im letzten Schritt wird das Array nochmals mit Quicksort sortiert und zurückgeben.

	\lstinputlisting[style=intext,linerange={106,110,112,113,115,116,117}, caption={Ausschnitt 1 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A1.py}]{../Code/DCE/DCE.py}

	\lstinputlisting[firstnumber=8,style=intext,linerange={120,121,122,123,124,125}, caption={Ausschnitt 2 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A2.py}]{../Code/DCE/DCE.py}

	\lstinputlisting[firstnumber=14,style=intext,linerange={128,129,130,131,132,134,135,136,137,138}, caption={Ausschnitt 3 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A3.py}]{../Code/DCE/DCE.py}

	\lstinputlisting[firstnumber=24,style=intext,linerange={140,141,142,143,145,146,147,148}, caption={Ausschnitt 4 aus \protect\lstinline|update_sort_array_sec| Funktion in DCE.py}, label = {cd:update_sort_arr_sec_A4.py}]{../Code/DCE/DCE.py}
	

	
	
}


\section{Shape Similarity Measure (SSM)}{
	\label{py:Shape_Sim_Meas}
	Beide Versionen der YOLO Implementierung erzeugen ein mehrdimensionales Array, welches für jedes Frame jedes Polygon mit Gesamtwinkelsumme, Class ID und Umriss enthält. Dieses mehrdimensionale Array wird ausgewertet, um einzuschätzen, ob die DCE zum Objekttracking geeignet ist. 

	Die Ergebnisse werden in einem weiteren Dictionary gespeichert, welches als letzten Schritt in eine Textdatei geschrieben wird, um alle Ergebnisse und Einstellungen zentral zu speichern. In Listing \ref{cd:SSM_main.py} ist zu sehen, in welcher Reihenfolge das \lstinline|result_dictionary| mit Elementen gefüllt wird. Die ersten Zeilen des Dictionary bestehen immer aus einer Zeitangabe, wann das Programm abgeschlossen wurde und Daten zu den Polygonen und Winkeln. Hier werden für jeden Testfall die Anzahl der verglichenen Polygone, die Gesamtanzahl dieser gespeichert. Außerdem wird die Zahl der verglichenen Winkel und die Punktanzahl der Polygone vor und nach der Vereinfachung durch DCE aufgelistet. \\
	Wenn die ersten Zeilen im Dictionary geschrieben wurden, wird der Formähnlichkeitsmesswert, im folgenden auch als \glqq Shape Similarity Measure\grqq{} (SSM) bezeichnet, berechnet. Nach diesem Schritt werden die Zeitstempel kalkuliert und in das \lstinline|result_dictionary| geschrieben, sowie die Programmeinstellungen im Dictionary gespeichert. Der letzte Schritt besteht daraus, dass \lstinline|result_dictionary| als Textdatei an dem entsprechend festgelegten Pfad zu speichern.

	Die \lstinline|calc_SSM_illustration| Funktion läuft folgendermaßen ab. Nachdem aus dem \lstinline|options| Dictionary die Liste aller Polygone in eine neue Variable gespeichert wurde, kann über diese Variable iteriert werden. Hierfür wird die Anzahl der Frames, bzw. die Länge des Arrays genutzt, da mit jedem Frame alle Polygone die in diesem detektiert wurden, verknüpft sind. \\
	In der FOR Schleife wird zunächst mit einer IF Abfrage eine Variable (\lstinline|compare_polys|) mit der geringeren Polygonanzahl zum nächsten Frame initialisiert. Dies ist wichtig, da das Frame mit der geringeren Polygonanzahl die Berechnung des Formähnlichkeitsmesswertes limitiert, um nur Polygone zu vergleichen, die auch im nächsten Frame noch vorhanden sind. In dieser IF Abfrage wird auch eine Zählvariable erhöht, die die Zahl der verglichenen Polygone speichert. \\
	Im nächsten Schritt wird über alle Polygone des jeweiligen Frames mit einer weiteren FOR Schleife iteriert. Da nur Polygone verglichen werden dürfen, deren detektierte Klasse die gleiche ist, ist in dieser Schleife ein MATCH CASE Fall vorhanden. Hier wird nach den drei Hauptklassen und \lstinline|other_Objects|, bzw. anderen Klassen, unterschieden. Wenn im aktuellen und im nächsten Frame die gleichen Klassen bei dem gleichen Polygon erkannt wurden, kann die geringste SSM mit der Methode \lstinline|calc_minor_SSM| berechnet werden. Dieser Rückgabewert wird dann dem Array übergeben, welches alle Werte speichert. Bei allen drei Hauptklassen geschieht dies ähnlich. Wenn jedoch eine andere Klasse erkannt wurde, wird dem entsprechenden Array die Klassen ID und der geringste SSM als Tupel hinzugefügt. \\
	Damit sind die beiden ineinander verschachtelten FOR Schleifen durchlaufen und die Anzahl der detektierten Objekte für jede Hauptklasse kann an der Länge der Arrays mit den SSM Werten gespeichert werden. Dies ist der Fall, weil für jedes detektierte Objekt der Klassen exakt ein Element in das Array gespeichert wurde, welches die geringste Abweichung besitzt. Für das Array, welches die Tupel mit allen weiteren Objekten enthält, wird eine Methode aufgerufen, die von Bucketsort inspiriert wurde, in welcher alle Elemente nach der jeweiligen Klasse sortiert und in Teilen summiert werden. \todo{ Sortierung Ausführlicher beschreiben?}. \\
	Im nächsten Schritt werden die berechneten Werte in das \lstinline|result_dictionary| gespeichert. Dies geschieht alle Objekte, die nicht den Hauptklassen entsprechen, mit einer FOR Schleife, damit die Ausgabe dynamisch an alle erkannten Klassen angepasst werden kann. Damit ist diese Funktion abgeschlossen. \\

	Die Funktion \lstinline|calc_minor_SSM| arbeitet mit zwei Arrays, die die jeweiligen Winkelindizes und Winkel für jeden Punkt für jeweils ein Polygon enthalten. Es wird zunächst ein Array initialisiert, indem alle berechneten SSMs gespeicehrt werden. Danach wird eine FOR Schleife genutzt um alle Permutationen für den Vergleich der beiden Arrays zu durchlaufen. In dieser Schleife ist eine IF Abfrage vorhanden, um zu verhindern, dass ein Array keine Werte zum Vergleich enthält (bzw. die Länge 0 hat). Wenn kein Array die Länge 0 besitzt, kann die \lstinline|compare_arrays| Methode gestartet werden, die alle Elemente des ersten Arrays von allen Elementen des zweiten Arrays an der gleichen Stele abzieht. Dieser SSM wird dann dem Array hinzugefügt und das zweite Polygon wird um ein Element verschoben. Bei dem zweiten Array wird das unterste Element zum ersten Element kopiert, sodass das Array permutiert. Diese Schritte wiederholen sich, bis das zweite Array einmal vollständig permutiert wurde. Danach wird aus dem \lstinline|SSM_arr| Array der geringste Wert und der Index von diesem Wert mit Numpy internen Funktionen gesucht und als Array zurückgegeben. \\

	In der Funktion \lstinline|compare_arr| wird zunächst eine Variable gespeichert, die die Länge des kürzesten Arrays von beiden besitzt. Anhand dieser wird die folgende FOR Schleife limitiert, damit nur Werte verglichen werden, für die auch ein Gegenstück vorhanden ist.
	In der FOR Schleife wird ein Variable erhöht, indem immer der Absolutbetrag der Differenzen zwischen dem ersten Array an der entsprechenden Stelle und dem zweiten Array an der gleichen Stelle addiert wird. Dieser Absolutbetrag sorgt dafür, dass die Variable gegen 0 geht und das Formähnlichkeitsmaß eine bessere Formähnlichkeit durch einen geringeren Wert repräsentiert. Danach wird die Variable zur weiteren Verarbeitung zurückgeben.

	
	


	\lstinputlisting[style=intext, linerange={53,62,63,83,85,86,87,88,89,90,91}, caption={Ausschnitt 1 aus \protect\lstinline|calc_SSM_illustration| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_illu_A1.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}

	\lstinputlisting[style=intext, linerange={93,95,96,67,98,99,100,101,112,113,114,115,116}, caption={Ausschnitt 2 aus \protect\lstinline|calc_SSM_illustration| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_illu_A2.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}

	\lstinputlisting[style=intext, linerange={118,119,120,122,124,125,126,127,128,130,131,135}, caption={Ausschnitt 3 aus \protect\lstinline|calc_SSM_illustration| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_illu_A3.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}

	\lstinputlisting[style=intext, linerange={230,238-248,255}, caption={Ausschnitt aus \protect\lstinline|calc_minor_SSM| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_calc_minor_SSM.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}


	\lstinputlisting[style=intext, linerange={260,269-278,280,282-284,286,291,298-302}, caption={Ausschnitte aus \protect\lstinline|compare_arrays| und \protect\lstinline|permute_arr| Funktionen in shape\_sim\_meas.py}, label = {cd:SSM_compare_and_permute_arr.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\todo{Listing ist eigentlich überflüssig? zumindest permute Arr}
	
	\lstinputlisting[style=intext, linerange={200,209-212,214-217,219-223,225}, caption={Ausschnitt aus \protect\lstinline|sort_oO_arr_new| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_sort_oO_arr.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\todo{Listing ist eigentlich überflüssig?}
	
	\lstinputlisting[style=intext, linerange={29,37,38,40,45,46,47,48}, caption={Ausschnitt aus \protect\lstinline|calc_shape_similarity| Funktion in shape\_sim\_meas.py}, label = {cd:SSM_main.py}]{../Code/Shape_Similiarity/shape_sim_meas.py}
	\todo{Listing ist eigentlich überflüssig?}









}







